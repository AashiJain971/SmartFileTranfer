<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Speed Detection Test</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 20px;
            background: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .file-input {
            margin: 20px 0;
            padding: 10px;
            border: 2px dashed #ddd;
            border-radius: 8px;
            text-align: center;
        }
        .results {
            background: #f8f9fa;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .chunk-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .chunk-option {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
        }
        .chunk-option.selected {
            border-color: #007bff;
            background: #e3f2fd;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .status.testing { background: #fff3cd; color: #856404; }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover { background: #0056b3; }
        .estimation {
            background: #e8f4fd;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #17a2b8;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üöÄ Smart Network Detection Test</h1>
        <p>This demonstrates the improved network detection that fixes the "735KB file with 4MB chunks" issue.</p>
        
        <div class="file-input">
            <input type="file" id="fileInput" style="display: none;" onchange="handleFileSelect(event)">
            <div onclick="document.getElementById('fileInput').click()" style="cursor: pointer;">
                üìÅ Click to select a test file (or create a 735KB test file)
            </div>
        </div>
        
        <div class="chunk-info">
            <div class="chunk-option selected" id="autoOption">
                <h3>üîÑ Automatic (Network-based)</h3>
                <div>üìä Auto-detected: <span id="autoChunkSize">Click "Test Network" first</span></div>
                <div id="networkStatus" class="status">Ready for testing</div>
            </div>
            
            <div class="chunk-option" id="manualOption">
                <h3>‚öôÔ∏è Manual Selection</h3>
                <select id="manualChunkSize">
                    <option value="131072">128 KB</option>
                    <option value="262144">256 KB</option>
                    <option value="524288">512 KB</option>
                    <option value="1048576">1 MB</option>
                    <option value="2097152">2 MB</option>
                    <option value="4194304">4 MB</option>
                </select>
            </div>
        </div>
        
        <div style="text-align: center; margin: 20px 0;">
            <button onclick="testNetworkSpeed()">üß™ Test Network Speed</button>
            <button onclick="createTestFile()">üìÑ Create 735KB Test File</button>
        </div>
        
        <div id="results" class="results" style="display: none;">
            <h3>üìà Results</h3>
            <div id="resultContent"></div>
        </div>
        
        <div id="estimation" class="estimation" style="display: none;">
            <h3>üìä Upload Estimation</h3>
            <div id="estimationContent"></div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8001';
        let selectedFile = null;

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function handleFileSelect(event) {
            selectedFile = event.target.files[0];
            if (selectedFile) {
                showFileInfo();
                if (document.getElementById('autoOption').classList.contains('selected')) {
                    testNetworkSpeed();
                }
            }
        }

        function createTestFile() {
            // Create a 735KB test file
            const size = 735 * 1024; // 735KB
            const content = new Array(size).fill('a').join('');
            const blob = new Blob([content], { type: 'text/plain' });
            selectedFile = new File([blob], 'test_735kb.txt', { type: 'text/plain' });
            
            document.getElementById('results').style.display = 'block';
            document.getElementById('resultContent').innerHTML = `
                <strong>üìÑ Test file created:</strong> ${selectedFile.name}<br>
                <strong>üìè Size:</strong> ${formatBytes(selectedFile.size)} (exactly 735KB)<br>
                <em>Now click "Test Network Speed" to see the smart chunk selection!</em>
            `;
            
            showFileInfo();
        }

        function showFileInfo() {
            if (!selectedFile) return;
            
            const estimation = document.getElementById('estimation');
            const content = document.getElementById('estimationContent');
            
            estimation.style.display = 'block';
            content.innerHTML = `
                <strong>üìÅ Selected File:</strong> ${selectedFile.name}<br>
                <strong>üìè File Size:</strong> ${formatBytes(selectedFile.size)}<br>
                <em>Network speed detection will optimize chunk size for this file...</em>
            `;
        }

        async function testNetworkSpeed() {
            const statusDiv = document.getElementById('networkStatus');
            const chunkSizeDiv = document.getElementById('autoChunkSize');
            const resultsDiv = document.getElementById('results');
            const resultContent = document.getElementById('resultContent');
            
            try {
                statusDiv.className = 'status testing';
                statusDiv.textContent = 'Testing network speed...';
                
                // Test with multiple approaches since backend might not be available
                const testSizes = [50, 100, 250]; // KB sizes
                let totalSpeed = 0;
                let successfulTests = 0;
                let testResults = [];
                
                for (const sizeKb of testSizes) {
                    try {
                        statusDiv.textContent = `Testing ${sizeKb}KB download...`;
                        
                        const startTime = performance.now();
                        
                        // Try the speedtest endpoint first, fallback to health endpoint
                        let response;
                        try {
                            response = await fetch(`${API_BASE}/speedtest/${sizeKb}`, {
                                cache: 'no-cache',
                                headers: { 'Cache-Control': 'no-cache' }
                            });
                        } catch (e) {
                            // Fallback: simulate load by requesting health multiple times
                            console.log(`Speedtest endpoint not available, using fallback for ${sizeKb}KB`);
                            const healthTests = Math.ceil(sizeKb / 10);
                            for (let i = 0; i < healthTests; i++) {
                                try {
                                    await fetch(`${API_BASE}/health?t=${Date.now()}&i=${i}`, { cache: 'no-cache' });
                                } catch (e) {
                                    // Even health endpoint not available - simulate with delay
                                    await new Promise(resolve => setTimeout(resolve, 5));
                                }
                            }
                            
                            const endTime = performance.now();
                            const duration = (endTime - startTime) / 1000;
                            const estimatedSize = sizeKb * 1024;
                            const speed = estimatedSize / duration;
                            
                            totalSpeed += speed;
                            successfulTests++;
                            testResults.push(`${sizeKb}KB: ${formatBytes(speed)}/s (simulated)`);
                            continue;
                        }
                        
                        if (response && response.ok) {
                            const data = await response.arrayBuffer();
                            const endTime = performance.now();
                            const duration = (endTime - startTime) / 1000;
                            const speed = data.byteLength / duration;
                            
                            totalSpeed += speed;
                            successfulTests++;
                            testResults.push(`${sizeKb}KB: ${formatBytes(speed)}/s (real)`);
                        }
                    } catch (err) {
                        console.warn(`Test ${sizeKb}KB failed:`, err);
                        testResults.push(`${sizeKb}KB: Failed`);
                    }
                }
                
                let avgSpeed = 0;
                if (successfulTests > 0) {
                    avgSpeed = totalSpeed / successfulTests;
                } else {
                    // Ultimate fallback - conservative estimate
                    avgSpeed = 512 * 1024; // 512KB/s
                    testResults.push('Using conservative fallback speed');
                }
                
                // Calculate optimal chunk size
                const speedKBps = avgSpeed / 1024;
                let recommendedChunkSize, networkDescription;
                
                if (speedKBps >= 1024) { // >= 1MB/s
                    recommendedChunkSize = 2097152; // 2MB
                    networkDescription = `Excellent (${formatBytes(avgSpeed)}/s)`;
                } else if (speedKBps >= 512) { // >= 512KB/s
                    recommendedChunkSize = 1048576; // 1MB
                    networkDescription = `Good (${formatBytes(avgSpeed)}/s)`;
                } else if (speedKBps >= 256) { // >= 256KB/s
                    recommendedChunkSize = 524288; // 512KB
                    networkDescription = `Fair (${formatBytes(avgSpeed)}/s)`;
                } else if (speedKBps >= 128) { // >= 128KB/s
                    recommendedChunkSize = 262144; // 256KB
                    networkDescription = `Slow (${formatBytes(avgSpeed)}/s)`;
                } else {
                    recommendedChunkSize = 131072; // 128KB
                    networkDescription = `Very Slow (${formatBytes(avgSpeed)}/s)`;
                }
                
                // SMART FILE SIZE ADJUSTMENT (This is the key fix!)
                let adjustmentNote = '';
                if (selectedFile) {
                    const fileSize = selectedFile.size;
                    
                    // For very small files, use smaller chunks
                    if (fileSize <= 262144) { // <= 256KB
                        if (fileSize < 65536) { // < 64KB
                            recommendedChunkSize = fileSize;
                            adjustmentNote = ' (Single chunk for tiny file)';
                        } else {
                            recommendedChunkSize = Math.max(32768, Math.floor(fileSize / 2));
                            adjustmentNote = ' (Optimized for small file)';
                        }
                    }
                    // For files < 1MB, don't use chunks larger than 256KB
                    else if (fileSize < 1048576 && recommendedChunkSize > 262144) {
                        recommendedChunkSize = Math.min(262144, Math.max(65536, Math.floor(fileSize / 4)));
                        adjustmentNote = ' (Capped for medium file)';
                    }
                    // Never use chunks larger than 1/4 of file size
                    else if (recommendedChunkSize > fileSize / 4) {
                        recommendedChunkSize = Math.max(65536, Math.floor(fileSize / 4));
                        adjustmentNote = ' (File-size optimized)';
                    }
                }
                
                chunkSizeDiv.textContent = formatBytes(recommendedChunkSize);
                statusDiv.className = 'status success';
                statusDiv.textContent = networkDescription + adjustmentNote;
                
                // Show chunk count estimation
                if (selectedFile) {
                    const estimatedChunks = Math.ceil(selectedFile.size / recommendedChunkSize);
                    statusDiv.textContent += ` (~${estimatedChunks} chunks)`;
                }
                
                // Display detailed results
                resultsDiv.style.display = 'block';
                resultContent.innerHTML = `
                    <strong>üåê Network Speed:</strong> ${formatBytes(avgSpeed)}/s (${successfulTests} successful tests)<br>
                    <strong>üß© Recommended Chunk Size:</strong> ${formatBytes(recommendedChunkSize)}${adjustmentNote}<br>
                    <strong>üìä Test Details:</strong><br>
                    ${testResults.map(r => `&nbsp;&nbsp;‚Ä¢ ${r}`).join('<br>')}
                    ${selectedFile ? `<br><strong>üìà For your ${formatBytes(selectedFile.size)} file:</strong><br>
                    &nbsp;&nbsp;‚Ä¢ Estimated chunks: ${Math.ceil(selectedFile.size / recommendedChunkSize)}<br>
                    &nbsp;&nbsp;‚Ä¢ Transfer time: ~${((selectedFile.size / avgSpeed)).toFixed(1)}s<br>
                    &nbsp;&nbsp;‚Ä¢ Time per chunk: ~${(recommendedChunkSize / avgSpeed).toFixed(1)}s` : ''}
                `;
                
            } catch (error) {
                statusDiv.className = 'status error';
                statusDiv.textContent = 'Network test failed - using smart defaults';
                
                // Smart defaults based on file size
                let defaultChunkSize = 524288; // 512KB
                if (selectedFile) {
                    const fileSize = selectedFile.size;
                    if (fileSize < 524288) {
                        defaultChunkSize = Math.max(65536, Math.floor(fileSize / 2));
                    } else if (fileSize < 2097152) {
                        defaultChunkSize = 262144; // 256KB
                    }
                }
                
                chunkSizeDiv.textContent = formatBytes(defaultChunkSize);
                
                resultsDiv.style.display = 'block';
                resultContent.innerHTML = `
                    <strong>‚ö†Ô∏è Network test failed, using adaptive defaults:</strong><br>
                    <strong>üß© Default Chunk Size:</strong> ${formatBytes(defaultChunkSize)}<br>
                    ${selectedFile ? `<strong>üìä For your ${formatBytes(selectedFile.size)} file:</strong><br>
                    &nbsp;&nbsp;‚Ä¢ Estimated chunks: ${Math.ceil(selectedFile.size / defaultChunkSize)}` : ''}
                `;
            }
        }

        // Toggle between auto and manual modes
        document.getElementById('autoOption').onclick = function() {
            this.classList.add('selected');
            document.getElementById('manualOption').classList.remove('selected');
        };

        document.getElementById('manualOption').onclick = function() {
            this.classList.add('selected');
            document.getElementById('autoOption').classList.remove('selected');
        };
    </script>
</body>
</html>