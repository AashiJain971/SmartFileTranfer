<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart File Transfer - Complete Test Suite</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            margin: 0; 
            padding: 0;
            background-color: #f5f5f5; 
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        /* Authentication styles */
        .auth-container {
            max-width: 400px;
            margin: 20px auto;
            padding: 30px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .auth-form input {
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .auth-form button {
            padding: 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }
        
        .auth-form button:hover {
            background-color: #0056b3;
        }
        
        .auth-form button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .auth-toggle {
            text-align: center;
            margin-top: 15px;
            color: #666;
        }
        
        .auth-toggle a {
            color: #007bff;
            text-decoration: none;
            cursor: pointer;
        }
        
        .user-info {
            background-color: #e7f3ff;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        
        .logout-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            float: right;
        }
        
        .main-content {
            display: none;
        }
        
        /* Chat Application Layout */
        .chat-app {
            display: flex;
            height: 100vh;
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        
        /* Sidebar Styles */
        .sidebar {
            width: 300px;
            background: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #34495e;
        }
        
        .sidebar-header {
            padding: 20px;
            background: #34495e;
            border-bottom: 1px solid #4a5f7a;
        }
        
        .user-profile {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #3498db;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
        }
        
        .user-details h3 {
            margin: 0;
            font-size: 16px;
        }
        
        .user-details p {
            margin: 0;
            font-size: 12px;
            opacity: 0.7;
        }
        
        .chat-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .btn-small {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }
        
        .btn-primary {
            background: #3498db;
            color: white;
        }
        
        .btn-secondary {
            background: #95a5a6;
            color: white;
        }
        
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        
        .btn-warning {
            background: #ffc107;
            color: #212529;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        /* Chat Rooms List */
        .rooms-section {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }
        
        .rooms-header {
            padding: 15px 20px;
            background: #34495e;
            border-bottom: 1px solid #4a5f7a;
            position: sticky;
            top: 0;
        }
        
        .rooms-header h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .room-search {
            width: 100%;
            padding: 8px;
            border: 1px solid #4a5f7a;
            border-radius: 4px;
            background: #2c3e50;
            color: white;
            font-size: 12px;
        }
        
        .room-search::placeholder {
            color: #bdc3c7;
        }
        
        .rooms-list {
            padding: 0;
        }
        
        .room-item {
            padding: 15px 20px;
            cursor: pointer;
            border-bottom: 1px solid #34495e;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .room-item:hover {
            background: #34495e;
        }
        
        .room-item.active {
            background: #3498db;
        }
        
        .room-icon {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
        }
        
        .room-icon.direct {
            background: #e74c3c;
        }
        
        .room-icon.group {
            background: #f39c12;
        }
        
        .room-info {
            flex: 1;
        }
        
        .room-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 2px;
        }
        
        .room-last-message {
            font-size: 12px;
            opacity: 0.7;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .room-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
        }
        
        .room-time {
            font-size: 11px;
            opacity: 0.6;
        }
        
        .unread-count {
            background: #e74c3c;
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 10px;
            font-weight: bold;
            min-width: 16px;
            text-align: center;
        }
        
        /* Main Chat Area */
        .chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .chat-header {
            padding: 20px;
            background: #34495e;
            color: white;
            border-bottom: 1px solid #4a5f7a;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .chat-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .chat-title h3 {
            margin: 0;
            font-size: 18px;
        }
        
        .chat-status {
            font-size: 12px;
            opacity: 0.7;
        }
        
        .chat-actions {
            display: flex;
            gap: 10px;
        }
        
        /* Messages Area */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #ecf0f1;
            scroll-behavior: smooth;
        }
        
        /* WhatsApp-like Message Styling */
        .message-container {
            margin-bottom: 8px;
            display: flex;
            width: 100%;
        }
        
        .message-container.own-message {
            justify-content: flex-end;
        }
        
        .message-container.other-message {
            justify-content: flex-start;
        }
        
        .message-bubble {
            max-width: 65%;
            min-width: 120px;
            padding: 8px 12px;
            border-radius: 8px;
            position: relative;
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        .own-message .message-bubble {
            background: #dcf8c6;
            color: #303030;
            border-bottom-right-radius: 2px;
        }
        
        .other-message .message-bubble {
            background: white;
            color: #303030;
            border-bottom-left-radius: 2px;
        }
        
        .message-content-area {
            margin-bottom: 2px;
        }
        
        .text-content {
            font-size: 14px;
            line-height: 1.4;
            margin: 0;
        }
        
        .message-footer {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 4px;
            margin-top: 2px;
        }
        
        .message-time {
            font-size: 11px;
            color: #667781;
            margin-right: 4px;
        }
        
        .status-icon {
            font-size: 12px;
            line-height: 1;
        }
        
        .status-pending {
            color: #667781;
        }
        
        .status-sent {
            color: #667781;
        }
        
        .status-delivered {
            color: #667781;
        }
        
        .status-read {
            color: #53bdeb;
        }
        
        .status-failed {
            color: #e74c3c;
        }
        
        /* Date separator for grouping messages */
        .date-separator {
            text-align: center;
            margin: 16px 0;
        }
        
        .date-separator span {
            background: #e1f5fe;
            color: #0277bd;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }
        
        /* Sender name for group chats */
        .message-sender-name {
            font-size: 12px;
            font-weight: 600;
            color: #025144;
            margin-bottom: 2px;
        }
        
        .other-message .message-sender-name {
            color: #d32f2f;
        }
        
        .message-status {
            text-align: right;
            margin-top: 4px;
            font-size: 11px;
            opacity: 0.7;
        }
        
        .file-message {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 16px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 1px solid #dee2e6;
            border-radius: 12px;
            margin: 10px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.2s ease;
        }
        
        .file-message:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-color: #007bff;
        }
        
        .file-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            box-shadow: 0 2px 6px rgba(0,123,255,0.3);
        }
        
        .file-info {
            flex: 1;
            min-width: 0; /* Allow text truncation */
        }
        
        .file-name {
            font-weight: 600;
            margin-bottom: 4px;
            color: #2c3e50;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .file-size {
            font-size: 12px;
            color: #6c757d;
            font-weight: 500;
        }
        
        .file-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }
        
        .file-actions .btn-small {
            padding: 8px 16px;
            font-size: 12px;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .file-actions .btn-small:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0,123,255,0.3);
        }
        
        /* Message Input */
        .message-input-area {
            padding: 20px;
            background: white;
            border-top: 1px solid #dee2e6;
        }
        
        .message-input-container {
            display: flex;
            align-items: flex-end;
            gap: 12px;
            background: #f8f9fa;
            border-radius: 25px;
            padding: 8px;
        }
        
        .message-input {
            flex: 1;
            border: none;
            background: transparent;
            padding: 12px 16px;
            font-size: 14px;
            resize: none;
            max-height: 100px;
            min-height: 20px;
        }
        
        .message-input:focus {
            outline: none;
        }
        
        .input-actions {
            display: flex;
            gap: 8px;
        }
        
        .action-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: background-color 0.2s;
        }
        
        .file-btn {
            background: #95a5a6;
            color: white;
        }
        
        .send-btn {
            background: #3498db;
            color: white;
        }
        
        .action-btn:hover {
            opacity: 0.8;
        }
        
        .action-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        
        /* Welcome Screen */
        .welcome-screen {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #7f8c8d;
            background: #ecf0f1;
        }
        
        .welcome-screen h2 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            background: #34495e;
            border-bottom: 1px solid #2c3e50;
            padding: 0;
        }
        
        .tab-button {
            background: transparent;
            border: none;
            color: #bdc3c7;
            padding: 15px 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }
        
        .tab-button:hover {
            background: rgba(52, 152, 219, 0.1);
            color: #3498db;
        }
        
        .tab-button.active {
            color: #3498db;
            border-bottom-color: #3498db;
            background: rgba(52, 152, 219, 0.1);
        }
        
        .tab-badge {
            background: #e74c3c;
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 11px;
            margin-left: 8px;
            min-width: 16px;
            text-align: center;
            display: none;
        }
        
        /* Tab Content */
        .tab-content {
            display: none;
            height: calc(100vh - 120px);
            overflow: hidden;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Logs Container */
        .logs-container {
            height: 100%;
            display: flex;
            flex-direction: column;
            background: #2c3e50;
        }
        
        .logs-header {
            background: #34495e;
            padding: 15px 20px;
            border-bottom: 1px solid #2c3e50;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logs-header h3 {
            margin: 0;
            color: #ecf0f1;
            font-size: 18px;
        }
        
        .logs-controls {
            display: flex;
            gap: 10px;
        }
        
        /* System Logs */
        .system-logs {
            background: #1a252f;
            color: #ecf0f1;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            line-height: 1.4;
        }
        
        .log-entry {
            margin: 4px 0;
            padding: 8px 12px;
            border-left: 4px solid transparent;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.02);
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        
        .log-timestamp {
            color: #95a5a6;
            font-weight: bold;
            min-width: 80px;
            flex-shrink: 0;
        }
        
        .log-message {
            flex: 1;
            word-wrap: break-word;
        }
        
        .log-entry.info {
            border-left-color: #3498db;
            background: rgba(52, 152, 219, 0.1);
        }
        
        .log-entry.success {
            border-left-color: #27ae60;
            background: rgba(39, 174, 96, 0.1);
            color: #2ecc71;
        }
        
        .log-entry.warning {
            border-left-color: #f39c12;
            background: rgba(243, 156, 18, 0.1);
            color: #f1c40f;
        }
        
        .log-entry.error {
            border-left-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
        }
        
        .log-entry.system {
            border-left-color: #9b59b6;
            background: rgba(155, 89, 182, 0.1);
            color: #af7ac5;
        }
        
        .log-entry.heartbeat {
            border-left-color: #95a5a6;
            background: rgba(149, 165, 166, 0.05);
            opacity: 0.7;
            font-size: 12px;
        }
        
        /* Dialog Styles */
        .dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .dialog-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
        }
        
        .dialog-header {
            margin-bottom: 20px;
        }
        
        .dialog-header h3 {
            margin: 0;
            color: #2c3e50;
        }
        
        .dialog-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        /* Connection Status */
        .connection-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .status-dot.connected {
            background: #27ae60;
        }
        
        .status-dot.disconnected {
            background: #e74c3c;
        }
        
        .status-dot.connecting {
            background: #f39c12;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Mobile Responsive */
        @media (max-width: 768px) {
            .chat-app {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
            }
            
            .message-content {
                max-width: 85%;
            }
        }
        
        /* Error and success messages */
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #f5c6cb;
        }
        
        .success-message {
            background-color: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #c3e6cb;
        }
        
        .warning-message {
            background-color: #fff3cd;
            color: #856404;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #ffeaa7;
        }
        
        /* Original styles */
        #messages { 
            border: 1px solid #ccc; 
            height: 400px; 
            overflow-y: scroll; 
            padding: 10px; 
            background-color: #f9f9f9;
            margin: 20px 0;
        }
        .message { 
            margin: 5px 0; 
            padding: 8px; 
            border-radius: 4px;
            border-left: 4px solid transparent;
        }
        .connected { background-color: #d4edda; }
        .chunk_started { background-color: #fff3cd; }
        .chunk_completed { background-color: #d1ecf1; }
        .chunk_failed { background-color: #f8d7da; }
        .upload_started { background-color: #e2e3e5; }
        .merging_started { background-color: #ffeaa7; }
        .completed { background-color: #d4edda; }
        .error { background-color: #f8d7da; }
        .heartbeat { background-color: #e9ecef; font-size: 12px; }
        
        /* HTTP Request/Response Styles */
        .http_request_start { background-color: #e3f2fd; border-left: 4px solid #2196f3; }
        .http_response_success { background-color: #e8f5e8; border-left: 4px solid #4caf50; }
        .http_response_error { background-color: #ffebee; border-left: 4px solid #f44336; }
        .http_exception { background-color: #fff3e0; border-left: 4px solid #ff9800; }
        
        /* WebSocket Message Styles */
        .ws_upload_started { background-color: #f3e5f5; border-left: 4px solid #9c27b0; }
        .ws_chunk_started { background-color: #fff8e1; border-left: 4px solid #ffc107; }
        .ws_chunk_completed { background-color: #fff3e0; border-left: 4px solid #ff9800; }
        .ws_merging_started { background-color: #e1f5fe; border-left: 4px solid #03a9f4; }
        .ws_progress_update { background-color: #f3e5f5; border-left: 4px solid #9c27b0; }
        .ws_completion { background-color: #e0f2f1; border-left: 4px solid #009688; }
        .ws_connected { background-color: #e8f5e8; border-left: 4px solid #4caf50; }
        .ws_message { background-color: #fafafa; border-left: 4px solid #757575; }
        .ws_parse_error { background-color: #ffebee; border-left: 4px solid #f44336; }
        button { padding: 10px 20px; margin: 5px; }
        input { padding: 8px; margin: 5px; width: 300px; }
        
        /* Real File Upload Styles */
        .upload-section {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            background-color: #fafafa;
        }
        .file-info {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        /* Upload Progress Styles */
        .upload-progress-container {
            padding: 20px;
            margin: 15px 10px;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border: 2px solid #2196f3;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
            animation: slideIn 0.3s ease-out;
            position: relative;
            z-index: 10;
        }
        
        @keyframes slideIn {
            from { 
                opacity: 0; 
                transform: translateY(-10px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }
        
        .upload-progress-container .upload-status {
            font-weight: 700;
            color: #0d47a1;
            margin-bottom: 12px;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .upload-progress-container .upload-status::before {
            content: '📤';
            font-size: 18px;
        }
        
        .progress-bar {
            width: 100%;
            height: 12px;
            background-color: #fff;
            border-radius: 6px;
            overflow: hidden;
            margin: 10px 0;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            border: 1px solid #e3f2fd;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50 0%, #2e7d32 100%);
            border-radius: 6px;
            transition: width 0.3s ease;
            box-shadow: 0 2px 4px rgba(76, 175, 80, 0.4);
            width: 0%;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 11px;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 1.5s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .upload-progress-container .progress-status {
            font-size: 13px;
            color: #1565c0;
            margin-top: 8px;
            font-weight: 600;
            text-align: center;
        }
        .chunk-info {
            font-size: 14px;
            color: #666;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <!-- Authentication Section -->
    <div id="authSection" class="auth-container">
        <h1 style="text-align: center; color: #2c3e50; margin-bottom: 30px;">
            SmartFileTransfer Chat
        </h1>
        <h2 id="authTitle">Login</h2>
        <form id="authForm" class="auth-form">
            <div id="signupFields" style="display: none;">
                <input type="text" id="username" name="username" placeholder="Username">
            </div>
            <input type="email" id="loginEmail" name="email" placeholder="Email" required>
            <input type="password" id="password" name="password" placeholder="Password" required>
            <button type="submit" id="authSubmitBtn">Login</button>
        </form>
        
        <div class="auth-toggle">
            <span id="authToggleText">Don't have an account?</span>
            <a id="authToggleLink" href="#" style="cursor: pointer;">Sign up</a>
        </div>
        
        <div id="authMessage"></div>
    </div>
    
    <!-- Main Chat Application (shown after login) -->
    <div id="mainContent" class="main-content">
        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-button active" data-tab="chat" onclick="switchTab('chat')">Chat</button>
            <button class="tab-button" data-tab="logs" onclick="switchTab('logs')">
                System Logs
                <span class="tab-badge" id="logsBadge">0</span>
            </button>
        </div>
        
        <!-- Chat Tab Content -->
        <div class="tab-content active" id="chatTab">
            <div class="chat-app">
                <!-- Sidebar -->
                <div class="sidebar">
                <!-- User Profile Header -->
                <div class="sidebar-header">
                    <div class="user-profile">
                        <div class="user-avatar" id="userAvatar">U</div>
                        <div class="user-details">
                            <h3 id="userDisplayName">User</h3>
                            <p id="userStatus">Online</p>
                        </div>
                    </div>
                    
                    <div class="chat-controls">
                        <button class="btn-small btn-primary" onclick="showNewChatDialog()">New Chat</button>
                        <button class="btn-small btn-secondary" onclick="logout()">Logout</button>
                    </div>
                    
                    <!-- Connection Status -->
                    <div class="connection-indicator">
                        <span class="status-dot" id="connectionDot"></span>
                        <span id="connectionText">Connecting...</span>
                    </div>
                </div>
                
                <!-- Chat Rooms -->
                <div class="rooms-section">
                    <div class="rooms-header">
                        <h4>Messages</h4>
                        <input type="text" class="room-search" placeholder="Search conversations..." id="roomSearch">
                    </div>
                    
                    <div class="rooms-list" id="roomsList">
                        <!-- Rooms will be populated here -->
                    </div>
                </div>
            </div>
            
            <!-- Main Chat Area -->
            <div class="chat-main">
                <!-- Welcome Screen (shown when no room is selected) -->
                <div class="welcome-screen" id="welcomeScreen">
                    <h2>Welcome to SmartFileTransfer Chat</h2>
                    <p>Select a conversation or start a new one</p>
                    <p>Send files with adaptive chunking based on network speed</p>
                    <p>Real-time messaging with WebSocket connections</p>
                    <p>Secure authentication and file integrity verification</p>
                </div>
                
                <!-- Chat Interface (shown when room is selected) -->
                <div class="chat-interface" id="chatInterface" style="display: none;">
                    <!-- Chat Header -->
                    <div class="chat-header">
                        <div class="chat-title">
                            <div class="room-icon" id="currentRoomIcon">
                                <span id="currentRoomIconText">?</span>
                            </div>
                            <div>
                                <h3 id="currentRoomName">Chat Room</h3>
                                <div class="chat-status">
                                    <span id="currentRoomStatus">Click to view info</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="chat-actions">
                            <button class="btn-small btn-primary" onclick="showFileUploadDialog()" title="Share File">
                                File
                            </button>
                            <button class="btn-small btn-info" onclick="refreshCurrentRoomMessages()" title="Refresh Messages">
                                Refresh
                            </button>
                            <button class="btn-small btn-warning" onclick="testMessagesAPI()" title="Test API">
                                Test API
                            </button>
                            <button class="btn-small btn-success" onclick="sendTestMessage()" title="Send Test Message">
                                Send Test
                            </button>
                            <button class="btn-small btn-secondary" onclick="clearCurrentChatMessages()" title="Clear Messages">
                                Clear
                            </button>
                        </div>
                    </div>
                    
                    <!-- Messages Container -->
                    <div class="messages-container" id="messagesContainer">
                        <!-- Messages will be populated here -->
                    </div>
                    
                    <!-- Message Input -->
                    <div class="message-input-area">
                        <div class="message-input-container">
                            <textarea class="message-input" id="messageInput" placeholder="Type a message..." rows="1"></textarea>
                            <div class="input-actions">
                                <button class="action-btn file-btn" onclick="triggerFileUpload()" title="Attach File">
                                    [File]
                                </button>
                                <button class="action-btn send-btn" onclick="sendMessage()" id="sendBtn" title="Send Message">
                                    ➤ Send
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </div>
        
        <!-- System Logs Tab Content -->
        <div class="tab-content" id="logsTab">
            <div class="logs-container">
                <div class="logs-header">
                    <h3>System Logs</h3>
                    <div class="logs-controls">
                        <button class="btn-small btn-secondary" onclick="clearSystemLogs()">Clear Logs</button>
                        <button class="btn-small btn-secondary" onclick="exportSystemLogs()">Export</button>
                    </div>
                </div>
                <div class="system-logs" id="systemLogs">
                    <div class="log-entry info">
                        <span class="log-timestamp">[INIT]</span>
                        <span class="log-message">Chat application initialized</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- New Chat Dialog -->
    <div class="dialog-overlay" id="newChatDialog">
        <div class="dialog-content">
            <div class="dialog-header">
                <h3>Start New Chat</h3>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; font-weight: bold;">Chat Type:</label>
                <div>
                    <label style="display: flex; align-items: center; margin-bottom: 10px;">
                        <input type="radio" name="chatType" value="direct" checked style="margin-right: 8px;">
                        Direct Message (1-on-1)
                    </label>
                    <label style="display: flex; align-items: center;">
                        <input type="radio" name="chatType" value="group" style="margin-right: 8px;">
                        Group Chat
                    </label>
                </div>
            </div>
            
            <div id="directChatSection">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">User Email:</label>
                <input type="email" id="directUserEmail" placeholder="Enter user email" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">
            </div>
            
            <div id="groupChatSection" style="display: none;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Group Name:</label>
                <input type="text" id="groupChatName" placeholder="Enter group name" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 15px;">
                
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Add Members (comma-separated emails):</label>
                <textarea id="groupMemberEmails" placeholder="user1@example.com, user2@example.com" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; height: 60px;"></textarea>
            </div>
            
            <div class="dialog-actions">
                <button class="btn btn-secondary" onclick="hideNewChatDialog()">Cancel</button>
                <button class="btn btn-primary" onclick="createNewChat()">Create Chat</button>
            </div>
        </div>
    </div>
    
    <!-- File Upload Dialog -->
    <div class="dialog-overlay" id="fileUploadDialog">
        <div class="dialog-content" style="max-width: 600px;">
            <div class="dialog-header">
                <h3>Send File</h3>
            </div>
            
            <div style="margin-bottom: 20px;">
                <input type="file" id="chatFileInput" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">
                <div id="chatFileInfo" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px; display: none;">
                    <!-- File info will be populated here -->
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; font-weight: bold;">Chunk Mode:</label>
                <div>
                    <label style="display: flex; align-items: center; margin-bottom: 10px;">
                        <input type="radio" name="chunkMode" value="auto" checked style="margin-right: 8px;">
                        <strong>Auto (Recommended)</strong> - Intelligent chunk sizing based on network speed
                    </label>
                    <label style="display: flex; align-items: center;">
                        <input type="radio" name="chunkMode" value="manual" style="margin-right: 8px;">
                        Manual chunk size selection
                    </label>
                </div>
                
                <div id="manualChunkSection" style="display: none; margin-top: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Chunk Size:</label>
                    <select id="manualChunkSize" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">
                        <option value="262144">256 KB (Slow Network)</option>
                        <option value="524288">512 KB (Normal Network)</option>
                        <option value="1048576" selected>1 MB (Fast Network)</option>
                        <option value="2097152">2 MB (Very Fast Network)</option>
                        <option value="4194304">4 MB (Excellent Network)</option>
                    </select>
                </div>
                
                <div id="networkStatus" style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 5px; font-size: 12px;">
                    <strong>Network Status:</strong> <span id="networkStatusText">Testing...</span><br>
                    <strong>Suggested Chunk Size:</strong> <span id="suggestedChunkSize">Calculating...</span>
                </div>
            </div>
            
            <div class="dialog-actions">
                <button class="btn btn-secondary" onclick="hideFileUploadDialog()">Cancel</button>
                <button class="btn btn-primary" onclick="startChatFileUpload()" id="startFileUploadBtn" disabled>Send File</button>
            </div>
        </div>
    </div>
    
    <!-- Hidden file input for quick access -->
    <input type="file" id="hiddenFileInput" style="display: none;" onchange="handleChatFileSelect()">
    
    <!-- Legacy elements for compatibility (hidden) -->
    <div style="display: none;">
        <div id="messages"></div>
        <div id="connectionStatus"></div>
        <div id="wsStatus"></div>
        <div id="wsIndicator"></div>
        <div id="status"></div>
        <input id="fileId" value="chat-session">
        <div id="fileInfo"></div>
        <div id="chunkInfo"></div>
        <div id="progressFill"></div>
        <div id="hashSection"></div>
        <div id="originalHash"></div>
        <div id="mergedHash"></div>
        <div id="integrityStatus"></div>
        <button id="uploadBtn"></button>
        <button id="pauseBtn"></button>
        <button id="resumeBtn"></button>
        <button id="cancelBtn"></button>
        <button id="downloadBtn"></button>
    </div>

    <script>
        // ============================================================================
        // SMARTFILETRANSFER CHAT APPLICATION - COMPREHENSIVE IMPLEMENTATION
        // ============================================================================
        
        // Global Application State
        let appState = {
            // Authentication
            isLoggedIn: false,
            user: null,
            userEmail: null,
            accessToken: null,
            refreshToken: null,
            
            // WebSocket & Chat
            chatWs: null,
            roomWs: null,  // Room-specific WebSocket for real-time messaging
            fileWs: null,
            connectionStatus: 'disconnected', // disconnected, connecting, connected
            heartbeatInterval: null,
            reconnectAttempts: 0,
            maxReconnectAttempts: 5,
            
            // Chat State
            currentRoom: null,
            rooms: new Map(), // roomId -> room data
            messages: new Map(), // roomId -> messages array
            unreadCounts: new Map(), // roomId -> unread count
            
            // File Upload State
            selectedFile: null,
            uploadState: {
                isUploading: false,
                isPaused: false,
                currentChunk: 0,
                totalChunks: 0,
                chunkSize: 1048576, // 1MB default
                uploadedBytes: 0,
                totalBytes: 0,
                originalHash: null,
                fileId: null
            },
            
            // Network & Performance
            networkSpeed: null,
            networkQuality: 'unknown',
            networkLatency: 0,
            suggestedChunkSize: 1048576,
            lastSpeedTest: null
        };

        // ============================================================================
        // UI CONTROL FUNCTIONS
        // ============================================================================
        
        function clearAuthMessage() {
            document.getElementById('authMessage').textContent = '';
            document.getElementById('authMessage').className = '';
        }
        
        function showChatApplication() {
            console.log('Showing chat application'); // Debug log
            
            // Hide auth section and show main content
            document.getElementById('authSection').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
            
            // Clear any auth messages
            clearAuthMessage();
            
            // Initialize the chat system if not already done
            if (typeof initializeChatSystem === 'function') {
                console.log('Initializing chat system...');
                initializeChatSystem().catch(error => {
                    console.error('Failed to initialize chat system:', error);
                    logSystem(`Failed to initialize chat: ${error.message}`, 'error');
                });
            }
            
            console.log('Chat application shown successfully'); // Debug log
        }
        
        function switchTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            document.getElementById(`${tabName}Tab`).classList.add('active');
            
            // Clear badge if switching to logs tab
            if (tabName === 'logs') {
                const badge = document.getElementById('logsBadge');
                badge.textContent = '0';
                badge.style.display = 'none';
            }
            
            console.log(`Switched to ${tabName} tab`);
        }
        
        function clearSystemLogs() {
            const systemLogs = document.getElementById('systemLogs');
            systemLogs.innerHTML = '<div class="log-entry info"><span class="log-timestamp">[CLEAR]</span><span class="log-message">System logs cleared</span></div>';
            console.log('System logs cleared');
        }
        
        function exportSystemLogs() {
            const systemLogs = document.getElementById('systemLogs');
            const logText = Array.from(systemLogs.children).map(entry => {
                const timestamp = entry.querySelector('.log-timestamp')?.textContent || '';
                const message = entry.querySelector('.log-message')?.textContent || entry.textContent;
                return `${timestamp} ${message}`;
            }).join('\n');
            
            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `system-logs-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            logSystem('System logs exported', 'success');
        }
        
        // ============================================================================
        // AUTHENTICATION SYSTEM
        // ============================================================================
        
        function initAuth() {
            logSystem('Initializing authentication system...');
            toggleAuthMode(false);
            
            // Check for existing token
            const token = localStorage.getItem('accessToken');
            const user = localStorage.getItem('user');
            
            if (token && user) {
                appState.accessToken = token;
                appState.refreshToken = localStorage.getItem('refreshToken');
                appState.user = JSON.parse(user);
                appState.userEmail = appState.user.email; // Store user email for room name display
                appState.isLoggedIn = true;
                
                // Update user display
                updateUserDisplay();
                
                showChatApplication();
            }
            
            // Setup form handler and event listeners
            const authForm = document.getElementById('authForm');
            const authToggleLink = document.getElementById('authToggleLink');
            
            console.log('Setting up auth event listeners:', { authForm, authToggleLink }); // Debug log
            
            if (authForm) {
                authForm.addEventListener('submit', handleAuthSubmit);
            }
            
            if (authToggleLink) {
                authToggleLink.addEventListener('click', toggleAuthMode);
                console.log('Auth toggle link event listener added'); // Debug log
            }
            
            // Setup chat type radio buttons
            document.querySelectorAll('input[name="chatType"]').forEach(radio => {
                radio.addEventListener('change', handleChatTypeChange);
            });
            
            // Setup chunk mode radio buttons
            document.querySelectorAll('input[name="chunkMode"]').forEach(radio => {
                radio.addEventListener('change', handleChunkModeChange);
            });
            
            // Setup message input
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.addEventListener('keydown', handleMessageInputKeydown);
                messageInput.addEventListener('input', autoResizeTextarea);
            }
            
            // Setup room search
            const roomSearch = document.getElementById('roomSearch');
            if (roomSearch) {
                roomSearch.addEventListener('input', handleRoomSearch);
            }
            
            logSystem('Authentication system initialized');
        }
        
        function toggleAuthMode(e) {
            if (e) e.preventDefault(); // Prevent default link behavior
            console.log('toggleAuthMode called'); // Debug log
            const signupFields = document.getElementById('signupFields');
            const usernameField = document.getElementById('username');
            const title = document.getElementById('authTitle');
            const submitBtn = document.getElementById('authSubmitBtn');
            const toggleText = document.getElementById('authToggleText');
            const toggleLink = document.getElementById('authToggleLink');
            
            console.log('Elements found:', { signupFields, usernameField, title, submitBtn, toggleText, toggleLink }); // Debug log
            
            const isSignup = signupFields.style.display === 'none';
            
            if (isSignup) {
                // Switch to signup mode
                signupFields.style.display = 'block';
                usernameField.setAttribute('required', 'required');
                title.textContent = 'Sign Up';
                submitBtn.textContent = 'Sign Up';
                toggleText.textContent = 'Already have an account?';
                toggleLink.textContent = 'Login';
            } else {
                // Switch to login mode
                signupFields.style.display = 'none';
                usernameField.removeAttribute('required');
                usernameField.value = ''; // Clear the hidden field
                title.textContent = 'Login';
                submitBtn.textContent = 'Login';
                toggleText.textContent = "Don't have an account?";
                toggleLink.textContent = 'Sign up';
            }
        }
        
        async function handleAuthSubmit(e) {
            e.preventDefault();
            console.log('Form submitted'); // Debug log
            
            const signupFields = document.getElementById('signupFields');
            const isSignup = signupFields && signupFields.style.display !== 'none';
            const submitBtn = document.getElementById('authSubmitBtn');
            const originalText = submitBtn.textContent;
            
            console.log('Auth mode:', isSignup ? 'signup' : 'login'); // Debug log
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Processing...';
            
            try {
                if (isSignup) {
                    await signup();
                } else {
                    await login();
                }
            } catch (error) {
                console.error('Auth error:', error); // Debug log
                showAuthMessage(error.message, 'error');
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        }
        
        async function signup() {
            const username = document.getElementById('username').value;
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('password').value;
            
            console.log('Attempting signup with:', { username, email }); // Debug log
            
            const response = await fetch('http://localhost:8000/auth/signup', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    username: username,
                    email: email,
                    password: password
                })
            });
            
            const data = await response.json();
            console.log('Signup response:', { status: response.status, data }); // Debug log
            
            if (!response.ok) {
                // Check for specific error messages
                if (response.status === 400 && (data.detail?.includes('already exists') || data.detail?.includes('already registered'))) {
                    showAuthMessage('Account already exists! Please login instead.', 'warning');
                    setTimeout(() => toggleAuthMode(), 2000); // Switch to login after 2 seconds
                    return;
                } else {
                    throw new Error(data.detail || 'Signup failed');
                }
            }
            
            showAuthMessage('Account created successfully! Please login.', 'success');
            setTimeout(() => toggleAuthMode(), 1500); // Switch to login after 1.5 seconds
        }
        
        async function login() {
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('password').value;
            
            console.log('Attempting login with email:', email); // Debug log
            
            const loginData = {
                email: email,
                password: password
            };
            
            const response = await fetch('http://localhost:8000/auth/login', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(loginData)
            });
            
            const data = await response.json();
            console.log('Login response:', { status: response.status, data }); // Debug log
            
            if (!response.ok) {
                if (response.status === 401) {
                    throw new Error('Invalid email or password. Please check your credentials.');
                } else if (response.status === 404) {
                    throw new Error('Account not found. Please sign up first.');
                } else {
                    throw new Error(data.detail || 'Login failed');
                }
            }
            
            // Store tokens and user info
            appState.accessToken = data.access_token;
            appState.refreshToken = data.refresh_token;
            appState.user = data.user;
            appState.userEmail = data.user.email; // Store user email for room name display
            appState.isLoggedIn = true;
            
            localStorage.setItem('accessToken', data.access_token);
            localStorage.setItem('refreshToken', data.refresh_token);
            localStorage.setItem('user', JSON.stringify(data.user));
            
            // Update user display
            updateUserDisplay();
            
            showChatApplication();
        }
        
        function updateUserDisplay() {
            if (appState.user) {
                // Update user display elements
                const userAvatar = document.getElementById('userAvatar');
                const userDisplayName = document.getElementById('userDisplayName');
                
                // Set username (use username if available, otherwise email before @)
                const displayName = appState.user.username || 
                                  (appState.user.email ? appState.user.email.split('@')[0] : 'User');
                
                if (userDisplayName) {
                    userDisplayName.textContent = displayName;
                }
                
                // Set avatar to first letter of display name
                if (userAvatar) {
                    userAvatar.textContent = displayName.charAt(0).toUpperCase();
                }
                
                console.log('User display updated:', { displayName, user: appState.user });
            }
        }
        
        function logout() {
            // Clear auth state
            appState.isLoggedIn = false;
            appState.user = null;
            appState.accessToken = null;
            appState.refreshToken = null;
            
            // Clear local storage
            localStorage.removeItem('accessToken');
            localStorage.removeItem('refreshToken');
            localStorage.removeItem('user');
            
            // Disconnect websocket if connected
            disconnectWebSocket();
            
            // Show auth section
            document.getElementById('authSection').style.display = 'block';
            document.getElementById('mainContent').style.display = 'none';
            
            showAuthMessage('Logged out successfully', 'success');
        }
        
        function showMainContent() {
            // Legacy compatibility - redirect to chat application
            showChatApplication();
        }
        
        function showAuthMessage(message, type) {
            const messageEl = document.getElementById('authMessage');
            messageEl.textContent = message;
            
            // Clear previous classes
            messageEl.className = '';
            
            // Set appropriate class based on type
            if (type === 'error') {
                messageEl.className = 'error-message';
            } else if (type === 'warning') {
                messageEl.className = 'warning-message';
            } else {
                messageEl.className = 'success-message';
            }
            
            console.log('Auth message shown:', { message, type }); // Debug log
        }
        
        // Enhanced fetch with auth
        async function authenticatedFetch(url, options = {}) {
            if (!appState.accessToken) {
                throw new Error('No access token available. Please login.');
            }
            
            const headers = {
                ...options.headers,
                'Authorization': `Bearer ${appState.accessToken}`
            };
            
            try {
                const response = await fetch(url, {
                    ...options,
                    headers
                });
                
                // Handle different auth errors
                if (response.status === 401) {
                    const errorData = await response.json().catch(() => ({}));
                    
                    // Try to refresh token
                    const refreshed = await refreshAccessToken();
                    if (refreshed) {
                        // Retry with new token
                        return fetch(url, {
                            ...options,
                            headers: {
                                ...options.headers,
                                'Authorization': `Bearer ${appState.accessToken}`
                            }
                        });
                    } else {
                        // Refresh failed, logout
                        logout();
                        throw new Error(`Authentication failed: ${errorData.detail || 'Session expired'}`);
                    }
                }
                
                if (response.status === 403) {
                    throw new Error('Access forbidden - insufficient permissions');
                }
                
                return response;
                
            } catch (error) {
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    throw new Error('Network error - check if backend server is running');
                }
                throw error;
            }
        }
        
        async function refreshAccessToken() {
            try {
                const response = await fetch('http://localhost:8000/auth/refresh', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        refresh_token: appState.refreshToken
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    appState.accessToken = data.access_token;
                    localStorage.setItem('accessToken', data.access_token);
                    return true;
                }
            } catch (error) {
                console.error('Token refresh failed:', error);
            }
            
            return false;
        }

        function updateStatus(status) {
            document.getElementById('status').textContent = `Status: ${status}`;
        }

        // Update WebSocket status indicator
        function updateWebSocketStatus(status, color) {
            document.getElementById('wsStatus').textContent = status;
            document.getElementById('wsIndicator').style.background = color;
        }

        function getWebSocketMessageDescription(messageType) {
            const descriptions = {
                'connected': 'Connection established',
                'upload_started': 'Upload session initiated',
                'chunk_started': 'Chunk upload began',
                'chunk_completed': 'Chunk upload finished',
                'chunk_failed': 'Chunk upload failed',
                'merging_started': 'File merging in progress',
                'completed': 'Upload completed successfully',
                'error': 'Error occurred',
                'heartbeat': 'Connection heartbeat',
                'progress': 'Progress update'
            };
            return descriptions[messageType] || 'Message received';
        }

        function addMessage(type, data) {
            const messages = document.getElementById('messages');
            const div = document.createElement('div');
            div.className = `message ${type}`;
            
            const timestamp = new Date(data.timestamp || new Date()).toISOString();
            const content = JSON.stringify(data, null, 2);
            
            div.innerHTML = `
                <strong>[${timestamp}] ${type.toUpperCase()}:</strong><br>
                <pre>${content}</pre>
            `;
            
            messages.appendChild(div);
            messages.scrollTop = messages.scrollHeight;
        }

        function connectWebSocket() {
            if (!appState.isLoggedIn || !appState.accessToken) {
                alert('Please login first');
                return;
            }
            
            const fileId = document.getElementById('fileId').value;
            if (!fileId) {
                alert('Please enter a file ID');
                return;
            }

            // Close existing connection
            if (ws) {
                ws.close();
            }

            currentFileId = fileId;
            
            // Add connection retry logic
            let connectionAttempts = 0;
            const maxAttempts = 3;
            
            function attemptConnection() {
                connectionAttempts++;
                
                // Add small delay before connection to ensure auth is ready
                setTimeout(() => {
                    const wsUrl = `ws://localhost:8000/ws/upload/${fileId}?token=${encodeURIComponent(appState.accessToken)}`;
                    
                    updateStatus(`Connecting... (attempt ${connectionAttempts}/${maxAttempts})`);
                    updateWebSocketStatus('Connecting...', '#ffc107');
                    addMessage('info', { 
                        message: `Attempting WebSocket connection (${connectionAttempts}/${maxAttempts})`, 
                        timestamp: new Date().toISOString() 
                    });
                    
                    ws = new WebSocket(wsUrl);
                    
                    // Set connection timeout
                    const connectionTimeout = setTimeout(() => {
                        if (ws.readyState === WebSocket.CONNECTING) {
                            ws.close();
                            addMessage('warning', {
                                message: 'WebSocket connection timeout',
                                attempt: connectionAttempts,
                                timestamp: new Date().toISOString()
                            });
                        }
                    }, 5000); // 5 second timeout
            
                    ws.onopen = function() {
                        clearTimeout(connectionTimeout);
                        connectionAttempts = 0; // Reset on success
                        updateStatus(`Connected to ${fileId}`);
                        updateWebSocketStatus('Connected', '#28a745');
                        addMessage('connected', { 
                            message: 'WebSocket connected successfully', 
                            timestamp: new Date().toISOString() 
                        });
                    };
                    
                    ws.onclose = function(event) {
                        clearTimeout(connectionTimeout);
                        updateStatus('Disconnected');
                        updateWebSocketStatus('Disconnected', '#dc3545');
                        
                        let reason = event.reason || 'Unknown reason';
                        
                        // Handle different close codes
                        if (event.code === 1006) {
                            // Connection failed before opening
                            if (connectionAttempts < maxAttempts) {
                                addMessage('warning', {
                                    message: `WebSocket connection failed, retrying in ${connectionAttempts} seconds...`,
                                    code: event.code,
                                    attempt: connectionAttempts,
                                    max_attempts: maxAttempts,
                                    timestamp: new Date().toISOString()
                                });
                                
                                // Exponential backoff: 1s, 2s, 3s
                                setTimeout(attemptConnection, connectionAttempts * 1000);
                                return;
                            } else {
                                reason = 'Failed to connect after multiple attempts';
                            }
                        } else if (event.code === 4001 || event.code === 4003) {
                            reason = 'Authentication failed - please login again';
                            setTimeout(() => logout(), 2000);
                        }
                        
                        addMessage('error', { 
                            message: 'WebSocket disconnected', 
                            code: event.code, 
                            reason: reason,
                            final_attempt: connectionAttempts >= maxAttempts,
                            timestamp: new Date().toISOString() 
                        });
                    };
                    
                    ws.onerror = function(error) {
                        clearTimeout(connectionTimeout);
                        updateStatus('Error');
                        
                        // Only show error if this is the final attempt to avoid spam
                        if (connectionAttempts >= maxAttempts) {
                            addMessage('error', { 
                                message: 'WebSocket error occurred', 
                                error: error.toString(),
                                attempt: connectionAttempts,
                                timestamp: new Date().toISOString() 
                            });
                        }
                    };
            
                    ws.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    
                    // Add WebSocket identifier to all messages
                    const wsMessage = {
                        ...data,
                        transport: 'WebSocket',
                        connection_type: 'Real-time bidirectional'
                    };
                    
                    // Log with WebSocket prefix based on message type
                    const messageType = `ws_${data.type || 'message'}`;
                    addMessage(messageType, {
                        message: `WebSocket: ${data.message || getWebSocketMessageDescription(data.type)}`,
                        transport: 'WebSocket',
                        ws_data: wsMessage,
                        timestamp: new Date().toISOString()
                    });
                    
                    // Also add the original message for backward compatibility
                    addMessage(data.type || 'message', data);
                    
                    // Handle specific WebSocket message types
                    if (data.type === 'chunk_completed' && data.progress) {
                        updateStatus(`Connected - Progress: ${data.progress.toFixed(1)}%`);
                        
                        addMessage('ws_progress_update', {
                            message: ` WebSocket: Progress update received`,
                            progress: data.progress,
                            uploaded_chunks: data.uploaded_chunks,
                            total_chunks: data.total_chunks,
                            transport: 'WebSocket',
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    if (data.type === 'upload_completed' || data.type === 'completed') {
                        addMessage('ws_completion', {
                            message: ` WebSocket: Upload completion notification`,
                            transport: 'WebSocket',
                            file_url: data.file_url || data.file_path,
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                } catch (e) {
                    addMessage('ws_parse_error', {
                        message: ` WebSocket: Failed to parse message`,
                        transport: 'WebSocket',
                        raw_data: event.data,
                        error: e.message,
                        timestamp: new Date().toISOString()
                    });
                }
                    };
                
                }, connectionAttempts === 1 ? 500 : 0); // Small delay only on first attempt
            }
            
            // Start the connection attempt
            attemptConnection();
        }

        function disconnectWebSocket() {
            if (ws) {
                ws.close();
                ws = null;
                updateStatus('Disconnected');
                updateWebSocketStatus('Disconnected', '#dc3545');
            }
        }

        function clearMessages() {
            document.getElementById('messages').innerHTML = '';
        }

        function sendPing() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'ping' }));
                console.log('Ping sent');
            } else {
                alert('WebSocket is not connected');
            }
        }

        function simulateUpload() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('WebSocket is not connected');
                return;
            }

            // Simulate a series of upload events
            const events = [
                { type: 'upload_started', filename: 'test-file.pdf', total_chunks: 5, file_size: 5120000 },
                { type: 'chunk_started', chunk_number: 0, chunk_size: 1048576 },
                { type: 'chunk_completed', chunk_number: 0, uploaded_chunks: 1, total_chunks: 5, progress: 20 },
                { type: 'chunk_started', chunk_number: 1, chunk_size: 1048576 },
                { type: 'chunk_completed', chunk_number: 1, uploaded_chunks: 2, total_chunks: 5, progress: 40 },
                { type: 'chunk_started', chunk_number: 2, chunk_size: 1048576 },
                { type: 'chunk_completed', chunk_number: 2, uploaded_chunks: 3, total_chunks: 5, progress: 60 },
                { type: 'chunk_started', chunk_number: 3, chunk_size: 1048576 },
                { type: 'chunk_completed', chunk_number: 3, uploaded_chunks: 4, total_chunks: 5, progress: 80 },
                { type: 'chunk_started', chunk_number: 4, chunk_size: 1048576 },
                { type: 'chunk_completed', chunk_number: 4, uploaded_chunks: 5, total_chunks: 5, progress: 100 },
                { type: 'merging_started', message: 'Merging chunks into final file...' },
                { type: 'completed', message: 'Upload completed successfully', file_path: '/uploaded_files/test-file.pdf' }
            ];

            let delay = 0;
            events.forEach((event, index) => {
                setTimeout(() => {
                    addMessage(event.type, { ...event, timestamp: new Date().toISOString() });
                    if (event.progress) {
                        updateStatus(`Connected - Progress: ${event.progress}%`);
                    }
                }, delay);
                delay += 1000; // 1 second between events
            });
        }

        // File upload functions
        async function handleFileSelect() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                document.getElementById('fileInfo').style.display = 'none';
                document.getElementById('uploadBtn').disabled = true;
                return;
            }

            selectedFile = file;
            uploadState.chunkSize = parseInt(document.getElementById('chunkSize').value);
            uploadState.totalBytes = file.size;
            uploadState.totalChunks = Math.ceil(file.size / uploadState.chunkSize);
            
            // Calculate file hash
            addMessage('info', { message: 'Calculating file hash...', timestamp: new Date().toISOString() });
            uploadState.originalHash = await calculateFileHash(file);
            
            // Display file info
            const fileInfo = document.getElementById('fileInfo');
            fileInfo.innerHTML = `
                <h4>Selected File:</h4>
                <p><strong>Name:</strong> ${file.name}</p>
                <p><strong>Size:</strong> ${formatBytes(file.size)}</p>
                <p><strong>Type:</strong> ${file.type || 'Unknown'}</p>
                <p><strong>Hash:</strong> ${uploadState.originalHash}</p>
                <p><strong>Chunks:</strong> ${uploadState.totalChunks} (${formatBytes(uploadState.chunkSize)} each)</p>
            `;
            fileInfo.style.display = 'block';
            
            // Update chunk info
            document.getElementById('chunkInfo').textContent = 
                `Ready to upload ${uploadState.totalChunks} chunks of ${formatBytes(uploadState.chunkSize)}`;
            
            document.getElementById('uploadBtn').disabled = false;
            addMessage('info', { 
                message: 'File selected and analyzed', 
                filename: file.name, 
                size: file.size, 
                hash: uploadState.originalHash, 
                timestamp: new Date().toISOString() 
            });
        }

        function updateChunkCalculation() {
            if (!selectedFile) return;
            
            const oldChunkSize = uploadState.chunkSize;
            uploadState.chunkSize = parseInt(document.getElementById('chunkSize').value);
            uploadState.totalChunks = Math.ceil(selectedFile.size / uploadState.chunkSize);
            
            // Update the file info display
            const fileInfo = document.getElementById('fileInfo');
            fileInfo.innerHTML = `
                <h4>Selected File:</h4>
                <p><strong>Name:</strong> ${selectedFile.name}</p>
                <p><strong>Size:</strong> ${formatBytes(selectedFile.size)}</p>
                <p><strong>Type:</strong> ${selectedFile.type || 'Unknown'}</p>
                <p><strong>Hash:</strong> ${uploadState.originalHash}</p>
                <p><strong>Chunks:</strong> ${uploadState.totalChunks} (${formatBytes(uploadState.chunkSize)} each)</p>
            `;
            
            // Update chunk info
            document.getElementById('chunkInfo').textContent = 
                `Ready to upload ${uploadState.totalChunks} chunks of ${formatBytes(uploadState.chunkSize)}`;
            
            addMessage('info', { 
                message: 'Chunk size updated', 
                old_chunk_size: formatBytes(oldChunkSize),
                new_chunk_size: formatBytes(uploadState.chunkSize),
                total_chunks: uploadState.totalChunks,
                timestamp: new Date().toISOString() 
            });
            
            console.log(`Chunk size changed: ${formatBytes(oldChunkSize)} -> ${formatBytes(uploadState.chunkSize)}`);
            console.log(`Total chunks: ${uploadState.totalChunks}`);
        }

        async function calculateFileHash(file) {
            const arrayBuffer = await file.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        async function calculateChunkHash(chunk) {
            const arrayBuffer = await chunk.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Enhanced error message extraction function
        function getDetailedErrorMessage(error) {
            if (!error) return 'No error provided';
            
            // Handle Response objects
            if (error instanceof Response) {
                return `HTTP ${error.status}: ${error.statusText}`;
            }
            
            // Handle Error objects - check if message is "[object Object]"
            if (error instanceof Error) {
                if (error.message === '[object Object]') {
                    // Try to extract more meaningful info from the error
                    try {
                        // Look for common error properties
                        if (error.cause) {
                            return `${error.name}: ${getDetailedErrorMessage(error.cause)}`;
                        }
                        if (error.stack) {
                            const stackLines = error.stack.split('\n');
                            return `${error.name}: ${stackLines[0] || 'Unknown error'}`;
                        }
                        // Try to get properties from the error object
                        const keys = Object.keys(error).filter(key => key !== 'message' && key !== 'name' && key !== 'stack');
                        if (keys.length > 0) {
                            const errorDetails = {};
                            keys.slice(0, 3).forEach(key => {
                                errorDetails[key] = error[key];
                            });
                            return `${error.name}: ${JSON.stringify(errorDetails)}`;
                        }
                        return `${error.name}: Error object with no readable message`;
                    } catch (e) {
                        return `${error.name}: Unable to extract error details`;
                    }
                } else {
                    return `${error.name}: ${error.message}`;
                }
            }
            
            // Handle fetch API errors
            if (error?.name === 'TypeError' && error?.message?.includes('fetch')) {
                return 'Network error: Unable to connect to server';
            }
            
            // Handle load/network failures
            if (error?.name === 'TypeError' && error?.message?.includes('Load failed')) {
                return 'Network error: Request failed to load (possible CORS or network issue)';
            }
            
            // Handle objects with error properties
            if (typeof error === 'object' && error !== null) {
                if (error.detail) return error.detail;
                if (error.message && error.message !== '[object Object]') return error.message;
                if (error.error) return error.error;
                
                // Try to stringify safely
                try {
                    const keys = Object.keys(error);
                    if (keys.length > 0) {
                        const relevantKeys = keys.slice(0, 5); // Limit to first 5 keys
                        const errorObj = {};
                        relevantKeys.forEach(key => {
                            try {
                                const value = error[key];
                                // Avoid circular references and objects that don't stringify well
                                if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
                                    errorObj[key] = value;
                                } else if (value && typeof value === 'object') {
                                    errorObj[key] = '[Object]';
                                } else {
                                    errorObj[key] = String(value);
                                }
                            } catch (e) {
                                errorObj[key] = '[Unreadable]';
                            }
                        });
                        return `Object error: ${JSON.stringify(errorObj)}`;
                    }
                } catch (e) {
                    return `Error object with keys: ${Object.keys(error).join(', ')}`;
                }
            }
            
            // Last resort - try to convert to string
            try {
                return String(error);
            } catch (e) {
                return 'Unreadable error object';
            }
        }

        async function startRealUpload() {
            if (!appState.isLoggedIn) {
                alert('Please login first');
                return;
            }
            
            if (!selectedFile) {
                alert('Please select a file first');
                return;
            }

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('Please connect WebSocket first');
                return;
            }

            // Reset upload state
            uploadState.isUploading = true;
            uploadState.isPaused = false;
            uploadState.currentChunk = 0;
            uploadState.uploadedBytes = 0;
            
            // Generate unique file ID for this upload (more entropy)
            const uploadFileId = `upload-${Date.now()}-${Math.random().toString(36).substr(2, 9)}-${Math.floor(Math.random() * 10000)}`;
            
            // Clean up any previous upload state
            if (currentFileId && currentFileId !== uploadFileId) {
                try {
                    await fetch(`http://localhost:8000/upload/cancel/${currentFileId}`, {
                        method: 'DELETE'
                    });
                } catch (e) {
                    console.log('Previous session cleanup failed:', e);
                }
            }
            
            // Update UI
            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('cancelBtn').disabled = false;

            // Start upload using the existing backend API
            try {
                let retryCount = 0;
                let result = null;
                
                while (retryCount < 3) {
                    try {
                        const formData = new FormData();
                        formData.append('file_id', uploadFileId);
                        formData.append('filename', selectedFile.name);
                        formData.append('total_chunks', uploadState.totalChunks.toString());
                        formData.append('file_size', uploadState.totalBytes.toString());
                        formData.append('file_hash', uploadState.originalHash);

                        console.log('Starting upload with:', {
                            file_id: uploadFileId,
                            filename: selectedFile.name,
                            total_chunks: uploadState.totalChunks,
                            file_size: uploadState.totalBytes,
                            hash: uploadState.originalHash
                        });

                        const response = await authenticatedFetch('http://localhost:8000/upload/start', {
                            method: 'POST',
                            body: formData
                        });

                        if (!response.ok) {
                            const errorData = await response.json();
                            
                            // If it's a network monitor error or duplicate key error, retry with new ID
                            if (errorData.detail && 
                                (errorData.detail.includes('mean requires at least one data point') || 
                                 errorData.detail.includes('already exists') ||
                                 errorData.detail.includes('duplicate key'))) {
                                retryCount++;
                                if (retryCount < 3) {
                                    // Generate new file ID for retry
                                    uploadFileId = `upload-${Date.now()}-${Math.random().toString(36).substr(2, 9)}-${Math.floor(Math.random() * 10000)}`;
                                    addMessage('info', { 
                                        message: `Retrying with new session ID in ${retryCount} seconds...`, 
                                        timestamp: new Date().toISOString() 
                                    });
                                    await new Promise(resolve => setTimeout(resolve, retryCount * 1000));
                                    continue;
                                }
                            }
                            
                            throw new Error(errorData.detail || errorData.message || `HTTP ${response.status}`);
                        }

                        result = await response.json();
                        break; // Success, exit retry loop
                        
                    } catch (error) {
                        if (retryCount === 2) throw error; // Last retry
                        retryCount++;
                        await new Promise(resolve => setTimeout(resolve, retryCount * 1000));
                    }
                }

                addMessage('upload_started', { 
                    file_id: uploadFileId,
                    filename: selectedFile.name, 
                    total_chunks: uploadState.totalChunks,
                    timestamp: new Date().toISOString() 
                });

                // Store file ID and start uploading chunks
                currentFileId = uploadFileId;
                await uploadNextChunk();

            } catch (error) {
                // Use enhanced error message extraction
                const errorMessage = getDetailedErrorMessage(error);
                
                addMessage('error', { 
                    message: 'Failed to start upload', 
                    error: errorMessage,
                    error_type: error?.constructor?.name || typeof error, 
                    timestamp: new Date().toISOString() 
                });
                
                console.error('Upload start error:', error);
                resetUploadUI();
            }
        }

        async function uploadNextChunk() {
            if (!uploadState.isUploading || uploadState.isPaused || uploadState.currentChunk >= uploadState.totalChunks) {
                return;
            }

            const chunkNumber = uploadState.currentChunk;
            const start = chunkNumber * uploadState.chunkSize;
            const end = Math.min(start + uploadState.chunkSize, uploadState.totalBytes);
            const chunk = selectedFile.slice(start, end);

            try {
                // Log HTTP request start
                addMessage('http_request_start', {
                    message: ` HTTP POST: Starting chunk ${chunkNumber} upload`,
                    chunk_number: chunkNumber,
                    chunk_size: chunk.size,
                    method: 'HTTP POST',
                    endpoint: '/upload/chunk',
                    transport: 'HTTP',
                    timestamp: new Date().toISOString()
                });

                // Calculate chunk hash
                const chunkHash = await calculateChunkHash(chunk);
                
                addMessage('chunk_started', { 
                    chunk_number: chunkNumber, 
                    chunk_size: chunk.size,
                    timestamp: new Date().toISOString() 
                });

                // Create form data
                const formData = new FormData();
                formData.append('file_id', currentFileId);
                formData.append('chunk_number', chunkNumber.toString());
                formData.append('total_chunks', uploadState.totalChunks.toString());
                formData.append('chunk_hash', chunkHash);
                formData.append('chunk', chunk);

                // Upload chunk using existing API (HTTP POST)
                const response = await authenticatedFetch('http://localhost:8000/upload/chunk', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (parseError) {
                        // Log HTTP error without JSON response
                        addMessage('http_response_error', {
                            message: `HTTP POST: Chunk ${chunkNumber} upload failed`,
                            chunk_number: chunkNumber,
                            method: 'HTTP POST',
                            status: response.status,
                            status_text: response.statusText,
                            error: `Failed to parse error response: ${parseError.message}`,
                            transport: 'HTTP',
                            timestamp: new Date().toISOString()
                        });
                        throw new Error(`HTTP ${response.status} - ${response.statusText} (Failed to parse error response)`);
                    }
                    
                    // Log HTTP error with JSON response
                    const errorMessage = errorData.detail || errorData.message || `HTTP ${response.status} - ${response.statusText}`;
                    addMessage('http_response_error', {
                        message: `HTTP POST: Chunk ${chunkNumber} upload failed`,
                        chunk_number: chunkNumber,
                        method: 'HTTP POST',
                        status: response.status,
                        status_text: response.statusText,
                        error: errorMessage,
                        error_data: errorData,
                        transport: 'HTTP',
                        timestamp: new Date().toISOString()
                    });
                    
                    console.log('Chunk upload error:', errorData);
                    // Ensure we throw a string message, not an object
                    const errorToThrow = typeof errorMessage === 'string' ? errorMessage : JSON.stringify(errorMessage);
                    throw new Error(errorToThrow);
                }

                const result = await response.json();

                // Log HTTP success response
                addMessage('http_response_success', {
                    message: ` HTTP POST: Chunk ${chunkNumber} uploaded successfully`,
                    chunk_number: chunkNumber,
                    method: 'HTTP POST',
                    status: response.status,
                    status_text: response.statusText,
                    response_data: result,
                    transport: 'HTTP',
                    timestamp: new Date().toISOString()
                });

                // Update progress
                uploadState.currentChunk++;
                uploadState.uploadedBytes += chunk.size;
                const progress = (uploadState.uploadedBytes / uploadState.totalBytes) * 100;

                updateProgressBar(progress);
                document.getElementById('chunkInfo').textContent = 
                    `Uploaded ${uploadState.currentChunk}/${uploadState.totalChunks} chunks (${progress.toFixed(1)}%)`;

                addMessage('chunk_completed', { 
                    chunk_number: chunkNumber, 
                    uploaded_chunks: uploadState.currentChunk, 
                    total_chunks: uploadState.totalChunks,
                    progress: progress,
                    timestamp: new Date().toISOString() 
                });

                // Continue with next chunk or complete upload
                if (uploadState.currentChunk < uploadState.totalChunks) {
                    // Small delay to prevent overwhelming the server
                    setTimeout(uploadNextChunk, 100);
                } else {
                    await completeUpload();
                }

            } catch (error) {
                // Use enhanced error message extraction
                const errorMessage = getDetailedErrorMessage(error);
                
                // Capture error details for debugging
                const errorDetails = {
                    name: error?.name,
                    message: error?.message,
                    stack: error?.stack?.split('\n').slice(0, 3), // First 3 lines of stack
                    type: error?.constructor?.name,
                    keys: typeof error === 'object' && error ? Object.keys(error) : [],
                    is_response: error instanceof Response,
                    is_error: error instanceof Error
                };

                // Log HTTP exception with better error info
                addMessage('http_exception', {
                    message: ` HTTP POST: Exception during chunk ${chunkNumber} upload`,
                    chunk_number: chunkNumber,
                    method: 'HTTP POST',
                    endpoint: '/upload/chunk',
                    error: errorMessage,
                    error_details: errorDetails,
                    error_type: error?.constructor?.name || typeof error,
                    transport: 'HTTP',
                    timestamp: new Date().toISOString()
                });
                
                addMessage('chunk_failed', { 
                    chunk_number: chunkNumber, 
                    error: errorMessage,
                    error_type: error?.constructor?.name || typeof error,
                    response_status: error instanceof Response ? error.status : 'N/A',
                    retry_in_seconds: 2,
                    timestamp: new Date().toISOString() 
                });
                
                // Log to console for debugging
                console.error('Chunk upload error details:', error);
                console.error('Processed error message:', errorMessage);
                
                // Retry logic - retry after 2 seconds
                setTimeout(() => uploadNextChunk(), 2000);
            }
        }

        async function completeUpload() {
            try {
                addMessage('merging_started', { 
                    message: 'Merging chunks and verifying integrity...', 
                    timestamp: new Date().toISOString() 
                });

                const formData = new FormData();
                formData.append('file_id', currentFileId);
                formData.append('expected_hash', uploadState.originalHash);

                const response = await authenticatedFetch('http://localhost:8000/upload/complete', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.detail || 'Failed to complete upload');
                }

                updateProgressBar(100);
                
                // Store uploaded file path for download
                uploadedFilePath = result.file_path;
                
                // Display hash verification
                displayHashVerification(uploadState.originalHash, result.merged_hash, result.integrity_verified);
                
                addMessage('completed', { 
                    message: 'Upload completed successfully', 
                    file_path: result.file_path,
                    file_id: result.file_id,
                    integrity_verified: result.integrity_verified,
                    original_hash: uploadState.originalHash,
                    merged_hash: result.merged_hash,
                    timestamp: new Date().toISOString() 
                });

                // Enable download button
                document.getElementById('downloadBtn').disabled = false;
                
                resetUploadUI();

            } catch (error) {
                // Use enhanced error message extraction
                const errorMessage = getDetailedErrorMessage(error);
                
                addMessage('error', { 
                    message: 'Failed to complete upload', 
                    error: errorMessage,
                    error_type: error?.constructor?.name || typeof error,
                    timestamp: new Date().toISOString() 
                });
                
                console.error('Upload completion error:', error);
                resetUploadUI();
            }
        }

        function updateProgressBar(percentage) {
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = `${percentage}%`;
            progressFill.textContent = `${percentage.toFixed(1)}%`;
        }

        function pauseUpload() {
            uploadState.isPaused = true;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('resumeBtn').disabled = false;
            addMessage('info', { message: 'Upload paused', timestamp: new Date().toISOString() });
        }

        function resumeUpload() {
            uploadState.isPaused = false;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('resumeBtn').disabled = true;
            addMessage('info', { message: 'Upload resumed', timestamp: new Date().toISOString() });
            uploadNextChunk();
        }

        async function cancelUpload() {
            uploadState.isUploading = false;
            uploadState.isPaused = false;
            
            // Clean up server session
            if (currentFileId) {
                try {
                    await authenticatedFetch(`http://localhost:8000/upload/cancel/${currentFileId}`, {
                        method: 'DELETE'
                    });
                    addMessage('info', { 
                        message: 'Upload cancelled and server session cleaned up', 
                        timestamp: new Date().toISOString() 
                    });
                } catch (err) {
                    console.error('Failed to cancel upload on server:', err);
                    addMessage('info', { 
                        message: 'Upload cancelled (server cleanup failed)', 
                        timestamp: new Date().toISOString() 
                    });
                }
                currentFileId = null;
            } else {
                addMessage('info', { message: 'Upload cancelled', timestamp: new Date().toISOString() });
            }

            resetUploadUI();
        }

        function resetUploadUI() {
            uploadState.isUploading = false;
            uploadState.isPaused = false;
            
            document.getElementById('uploadBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('resumeBtn').disabled = true;
            document.getElementById('cancelBtn').disabled = true;
            
            updateProgressBar(0);
            document.getElementById('chunkInfo').textContent = selectedFile ? 
                `Ready to upload ${uploadState.totalChunks} chunks of ${formatBytes(uploadState.chunkSize)}` : 
                'No file selected';
        }

        function displayHashVerification(originalHash, mergedHash, integrityVerified) {
            const hashSection = document.getElementById('hashSection');
            const originalHashSpan = document.getElementById('originalHash');
            const mergedHashSpan = document.getElementById('mergedHash');
            const integrityStatusSpan = document.getElementById('integrityStatus');
            
            originalHashSpan.textContent = originalHash || 'N/A';
            mergedHashSpan.textContent = mergedHash || 'N/A';
            
            if (integrityVerified && originalHash === mergedHash) {
                integrityStatusSpan.innerHTML = '<span style="color: green; font-weight: bold;"> VERIFIED - Hashes match</span>';
            } else {
                integrityStatusSpan.innerHTML = '<span style="color: red; font-weight: bold;"> FAILED - Hashes do not match</span>';
            }
            
            hashSection.style.display = 'block';
        }

        async function downloadUploadedFile() {
            if (!uploadedFilePath) {
                alert('No file available for download');
                return;
            }

            try {
                // Extract filename from path (handle both relative and absolute paths)
                let filename;
                if (uploadedFilePath.includes('/')) {
                    filename = uploadedFilePath.split('/').pop();
                } else {
                    filename = uploadedFilePath;
                }
                
                addMessage('info', { 
                    message: `Starting download of ${filename}...`, 
                    file_path: uploadedFilePath,
                    timestamp: new Date().toISOString() 
                });

                // Create download URL - encode the filename to handle special characters
                const downloadUrl = `http://localhost:8000/upload/download/${encodeURIComponent(filename)}`;
                
                // Try to download using fetch first to check if file exists
                const response = await authenticatedFetch(downloadUrl);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`File not found or download failed: ${response.status} - ${errorText}`);
                }

                // Create temporary link and trigger download
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);

                addMessage('info', { 
                    message: `Download completed: ${filename}`, 
                    timestamp: new Date().toISOString() 
                });

            } catch (error) {
                addMessage('error', { 
                    message: 'Download failed', 
                    error: error.message,
                    file_path: uploadedFilePath,
                    timestamp: new Date().toISOString() 
                });
            }
        }

        // Cleanup function to clear any stale sessions
        async function cleanupStaleSessions() {
            // Clear any stored file ID from previous sessions
            currentFileId = null;
            uploadedFilePath = null;
            
            // Reset upload state
            uploadState = {
                isUploading: false,
                isPaused: false,
                currentChunk: 0,
                totalChunks: 0,
                chunkSize: 1048576,
                uploadedBytes: 0,
                totalBytes: 0,
                originalHash: null
            };
            
            // Reset UI
            resetUploadUI();
            
            // Hide hash section and disable download button
            document.getElementById('hashSection').style.display = 'none';
            document.getElementById('downloadBtn').disabled = true;
        }

        // Warmup function to initialize network monitor
        async function warmupNetworkMonitor() {
            try {
                // Make a small dummy request to initialize the network monitor
                const response = await fetch('http://localhost:8000/health');
                if (response.ok) {
                    console.log('Network monitor warmed up successfully');
                }
            } catch (error) {
                console.log('Network warmup failed:', error);
            }
        }

        // ============================================================================
        // COMPREHENSIVE CHAT SYSTEM
        // ============================================================================
        
        async function initializeChatSystem() {
            logSystem('Initializing chat system...');
            
            // Connect to chat WebSocket
            await connectChatWebSocket();
            
            // Load user's chat rooms
            await loadChatRooms();
            
            // Ensure there's an active room and load messages
            await ensureActiveRoomWithMessages();
            
            // Start heartbeat
            startHeartbeat();
            
            logSystem('Chat system initialized successfully');
        }
        
        async function ensureActiveRoomWithMessages() {
            try {
                // Check if we have a previously selected room
                const savedRoomId = localStorage.getItem('currentRoom');
                if (savedRoomId && appState.rooms.has(savedRoomId)) {
                    await selectRoom(savedRoomId);
                    return;
                }
                
                // Check if we already have an active room
                if (appState.currentRoom && appState.rooms.has(appState.currentRoom)) {
                    await loadRoomMessages(appState.currentRoom);
                    return;
                }
                
                // Check if there are existing rooms
                if (appState.rooms.size > 0) {
                    // Select the first available room
                    const firstRoom = Array.from(appState.rooms.values())[0];
                    await selectRoom(firstRoom.id);
                    return;
                }
                
                // No rooms exist - don't auto-create, wait for user to create one
                logSystem('No existing rooms found. Use "New Chat" to start a conversation.', 'info');
                
            } catch (error) {
                logSystem(`Failed to ensure active room: ${error.message}`, 'error');
                console.error('Ensure active room error:', error);
            }
        }
        
        // ✅ CONNECT TO GENERAL CHAT WEBSOCKET (FOR INITIAL CONNECTION)
        async function connectChatWebSocket() {
            return new Promise((resolve, reject) => {
                // Enhanced authentication check
                if (!appState.accessToken) {
                    const error = new Error('No authentication token available');
                    logSystem('WebSocket connection failed: Not authenticated', 'error');
                    updateConnectionStatus('disconnected');
                    reject(error);
                    return;
                }
                
                if (!appState.user || !appState.user.id) {
                    const error = new Error('No user information available');
                    logSystem('WebSocket connection failed: No user data', 'error');
                    updateConnectionStatus('disconnected');
                    reject(error);
                    return;
                }
                
                logSystem('Connecting to general chat WebSocket...', 'info');
                console.log('WebSocket connection attempt with user:', appState.user.username);
                updateConnectionStatus('connecting');
                
                const wsUrl = `ws://localhost:8000/ws/chat?token=${encodeURIComponent(appState.accessToken)}`;
                console.log('WebSocket URL:', wsUrl);
                
                try {
                    appState.chatWs = new WebSocket(wsUrl);
                } catch (error) {
                    logSystem(`Failed to create WebSocket: ${error.message}`, 'error');
                    updateConnectionStatus('disconnected');
                    reject(error);
                    return;
                }
                
                const timeout = setTimeout(() => {
                    if (appState.chatWs.readyState === WebSocket.CONNECTING) {
                        appState.chatWs.close();
                        logSystem('Chat WebSocket connection timeout', 'error');
                        reject(new Error('Connection timeout'));
                    }
                }, 5000);
                
                appState.chatWs.onopen = function() {
                    clearTimeout(timeout);
                    updateConnectionStatus('connected');
                    logSystem('General chat WebSocket connected successfully', 'success');
                    appState.reconnectAttempts = 0;
                    
                    // Start heartbeat
                    startHeartbeat();
                    resolve();
                };
                
                // ... rest of the connection handling
                appState.chatWs.onclose = function(event) {
                    clearTimeout(timeout);
                    updateConnectionStatus('disconnected');
                    
                    let closeReason = event.reason || 'No reason provided';
                    let shouldReconnect = false;
                    
                    // Interpret close codes
                    switch (event.code) {
                        case 1000: // Normal closure
                            logSystem('Chat WebSocket closed normally', 'info');
                            break;
                        case 1001: // Going away
                            logSystem('Chat WebSocket closed: Page is being closed', 'info');
                            break;
                        case 1006: // Abnormal closure
                            logSystem('Chat WebSocket closed unexpectedly (connection lost)', 'warning');
                            shouldReconnect = true;
                            break;
                        case 4001: // Authentication error
                            logSystem('Chat WebSocket closed: Authentication failed - please login again', 'error');
                            setTimeout(() => logout(), 2000);
                            break;
                        case 4003: // Access denied
                            logSystem('Chat WebSocket closed: Access denied to room', 'error');
                            break;
                        default:
                            logSystem(`Chat WebSocket disconnected: Code ${event.code} - ${closeReason}`, 'warning');
                            shouldReconnect = event.code >= 1006; // Reconnect for unexpected closures
                    }
                    
                    console.log('WebSocket close event:', {
                        code: event.code,
                        reason: closeReason,
                        wasClean: event.wasClean
                    });
                    
                    // Stop heartbeat
                    stopHeartbeat();
                    
                    // Attempt reconnection only for recoverable errors
                    if (shouldReconnect && appState.reconnectAttempts < appState.maxReconnectAttempts) {
                        const delay = Math.pow(2, appState.reconnectAttempts) * 1000;
                        setTimeout(() => {
                            appState.reconnectAttempts++;
                            logSystem(`Attempting reconnection ${appState.reconnectAttempts}/${appState.maxReconnectAttempts}...`);
                            connectChatWebSocket().catch(err => {
                                logSystem(`Reconnection failed: ${err.message}`, 'error');
                            });
                        }, delay);
                    } else if (appState.reconnectAttempts >= appState.maxReconnectAttempts) {
                        logSystem('Max reconnection attempts reached', 'error');
                    }
                };
                
                appState.chatWs.onerror = function(error) {
                    clearTimeout(timeout);
                    console.error('WebSocket error details:', error);
                    console.error('WebSocket readyState:', appState.chatWs.readyState);
                    console.error('WebSocket URL:', wsUrl);
                    
                    let errorMessage = 'Connection failed';
                    if (error.type) {
                        errorMessage += ` (${error.type})`;
                    }
                    if (error.code) {
                        errorMessage += ` - Code: ${error.code}`;
                    }
                    if (error.reason) {
                        errorMessage += ` - Reason: ${error.reason}`;
                    }
                    
                    logSystem(`Chat WebSocket error: ${errorMessage}`, 'error');
                    
                    // Check if it's an authentication issue
                    if (appState.chatWs.readyState === WebSocket.CLOSED && !appState.accessToken) {
                        logSystem('WebSocket error may be due to missing authentication token', 'warning');
                    }
                };
                
                appState.chatWs.onmessage = function(event) {
                    handleChatMessage(JSON.parse(event.data));
                };
            });
        }
        
        // ✅ NEW: CONNECT TO ROOM-SPECIFIC WEBSOCKET FOR REAL-TIME MESSAGING
        async function connectToRoomWebSocket(roomId) {
            if (!roomId) return;
            
            // Close existing room WebSocket if exists
            if (appState.roomWs) {
                appState.roomWs.close();
                appState.roomWs = null;
            }
            
            return new Promise((resolve, reject) => {
                if (!appState.accessToken) {
                    reject(new Error('No authentication token'));
                    return;
                }
                
                logSystem(`Connecting to room WebSocket: ${roomId}`, 'info');
                const wsUrl = `ws://localhost:8000/ws/chat/${roomId}?token=${encodeURIComponent(appState.accessToken)}`;
                console.log('Room WebSocket URL:', wsUrl);
                
                try {
                    appState.roomWs = new WebSocket(wsUrl);
                } catch (error) {
                    logSystem(`Failed to create room WebSocket: ${error.message}`, 'error');
                    reject(error);
                    return;
                }
                
                const timeout = setTimeout(() => {
                    if (appState.roomWs.readyState === WebSocket.CONNECTING) {
                        appState.roomWs.close();
                        logSystem('Room WebSocket connection timeout', 'error');
                        reject(new Error('Room connection timeout'));
                    }
                }, 5000);
                
                appState.roomWs.onopen = function() {
                    clearTimeout(timeout);
                    logSystem(`✅ Connected to room ${roomId} for real-time messaging`, 'success');
                    resolve();
                };
                
                appState.roomWs.onclose = function(event) {
                    clearTimeout(timeout);
                    logSystem(`Room WebSocket disconnected: Code ${event.code}`, 'warning');
                };
                
                appState.roomWs.onerror = function(error) {
                    clearTimeout(timeout);
                    logSystem(`Room WebSocket error: ${error}`, 'error');
                };
                
                appState.roomWs.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    console.log('Room WebSocket message received:', data);
                    handleRoomMessage(data);
                };
            });
        }
        
        // ✅ HANDLE ROOM-SPECIFIC MESSAGES
        function handleRoomMessage(data) {
            switch (data.type) {
                case 'new_message':
                case 'message':
                    console.log('📨 New message received via room WebSocket:', data);
                    addMessageToChat(data.message || data);
                    break;
                case 'new_file_message':
                case 'file_message':
                    console.log('📎 New file message received via room WebSocket:', data);
                    addFileMessageToChat(data.message || data);
                    break;
                case 'user_joined':
                    logSystem(`${data.username} joined the room`, 'info');
                    break;
                case 'user_left':
                    logSystem(`${data.username} left the room`, 'info');
                    break;
                case 'typing':
                    handleTypingIndicator(data);
                    break;
                default:
                    console.log('Room WebSocket message:', data);
            }
        }
        

        
        function startHeartbeat() {
            if (appState.heartbeatInterval) {
                clearInterval(appState.heartbeatInterval);
            }
            
            appState.heartbeatInterval = setInterval(() => {
                if (appState.chatWs && appState.chatWs.readyState === WebSocket.OPEN) {
                    appState.chatWs.send(JSON.stringify({
                        type: 'heartbeat',
                        timestamp: new Date().toISOString()
                    }));
                    logSystem('Heartbeat sent', 'system');
                }
            }, 30000); // Send heartbeat every 30 seconds
        }
        
        function stopHeartbeat() {
            if (appState.heartbeatInterval) {
                clearInterval(appState.heartbeatInterval);
                appState.heartbeatInterval = null;
            }
        }
        
        function handleChatMessage(data) {
            logSystem(`WebSocket message received: ${data.type}`, 'info');
            
            switch (data.type) {
                case 'connected':
                    logSystem(`Connected to chat: ${data.message}`, 'success');
                    break;
                case 'message':
                case 'new_message':
                    addMessageToChat(data);
                    break;
                case 'file_message':
                case 'new_file_message':
                    addFileMessageToChat(data);
                    break;
                case 'room_created':
                    handleRoomCreated(data);
                    break;
                case 'user_joined':
                case 'user_left':
                    handleUserEvent(data);
                    break;
                case 'pong':
                case 'heartbeat_ack':
                    logSystem('Heartbeat acknowledged', 'system');
                    break;
                case 'error':
                    logSystem(`Chat error: ${data.message}`, 'error');
                    break;
                default:
                    logSystem(`Unknown message type: ${data.type}`, 'info');
                    break;
            }
        }
        

        
        async function loadChatRooms() {
            try {
                if (!appState.accessToken || !appState.isLoggedIn) {
                    logSystem('Cannot load chat rooms: not authenticated', 'warning');
                    return;
                }
                
                logSystem('Loading chat rooms...');
                
                const response = await authenticatedFetch('http://localhost:8000/chat/rooms');
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Load rooms error:', { status: response.status, text: errorText });
                    throw new Error(`Failed to load rooms: ${response.status} - ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Chat rooms response:', data); // Debug log
                appState.rooms.clear();
                
                // Handle both direct array and object with rooms property
                const rooms = Array.isArray(data) ? data : (data.rooms || []);
                
                if (Array.isArray(rooms)) {
                    rooms.forEach(room => {
                        appState.rooms.set(room.id, room);
                    });
                    updateRoomsList();
                    logSystem(`Loaded ${rooms.length} chat rooms`, 'success');
                } else {
                    throw new Error('Invalid response format: expected array of rooms');
                }
                
            } catch (error) {
                console.error('Chat rooms loading error:', error);
                logSystem(`Failed to load chat rooms: ${error.message}`, 'error');
                
                // Show empty state on error
                appState.rooms.clear();
                updateRoomsList();
            }
        }
        
        function updateRoomsList() {
            const roomsList = document.getElementById('roomsList');
            roomsList.innerHTML = '';
            
            if (appState.rooms.size === 0) {
                roomsList.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #bdc3c7;">
                        No conversations yet.<br>
                        <span style="font-size: 12px;">Click "New Chat" to start</span>
                    </div>
                `;
                return;
            }
            
            appState.rooms.forEach((room, roomId) => {
                const roomElement = createRoomElement(room);
                roomsList.appendChild(roomElement);
            });
        }

        function getRoomDisplayName(room) {
            if (room.type === 'direct') {
                // For direct messages, show the other user's name/email
                if (room.members && room.members.length > 0) {
                    console.log('Room members:', room.members);
                    console.log('Current user:', appState.user);
                    
                    // Find the member who is not the current user
                    const currentUserId = appState.user ? appState.user.id : null;
                    const currentUserEmail = appState.user ? appState.user.email : null;
                    
                    const otherUser = room.members.find(member => {
                        // Handle different member data structures
                        if (typeof member === 'string') {
                            return member !== currentUserEmail;
                        } else if (member && typeof member === 'object') {
                            return (member.user_id && member.user_id !== currentUserId) ||
                                   (member.email && member.email !== currentUserEmail) ||
                                   (member.id && member.id !== currentUserId);
                        }
                        return false;
                    });
                    
                    console.log('Other user found:', otherUser);
                    
                    if (otherUser) {
                        // Return username or email username part
                        let displayName = 'Unknown User';
                        
                        if (typeof otherUser === 'string') {
                            displayName = otherUser.includes('@') ? otherUser.split('@')[0] : otherUser;
                        } else if (otherUser.username) {
                            displayName = otherUser.username;
                        } else if (otherUser.email) {
                            displayName = otherUser.email.includes('@') ? otherUser.email.split('@')[0] : otherUser.email;
                        }
                        
                        console.log('Display name for room:', displayName);
                        return displayName;
                    }
                }
                return 'Direct Message';
            } else {
                // For group messages, use the provided name or default
                return room.name || 'Group Chat';
            }
        }
        
        function createRoomElement(room) {
            const roomElement = document.createElement('div');
            roomElement.className = 'room-item';
            roomElement.dataset.roomId = room.id;
            
            const roomIcon = document.createElement('div');
            roomIcon.className = `room-icon ${room.type}`;
            roomIcon.textContent = room.type === 'direct' ? 'D' : 'G';
            
            const roomInfo = document.createElement('div');
            roomInfo.className = 'room-info';
            
            const roomName = document.createElement('div');
            roomName.className = 'room-name';
            roomName.textContent = getRoomDisplayName(room);
            
            const roomLastMessage = document.createElement('div');
            roomLastMessage.className = 'room-last-message';
            roomLastMessage.textContent = room.last_message || 'No messages yet';
            
            roomInfo.appendChild(roomName);
            roomInfo.appendChild(roomLastMessage);
            
            const roomMeta = document.createElement('div');
            roomMeta.className = 'room-meta';
            
            const roomTime = document.createElement('div');
            roomTime.className = 'room-time';
            roomTime.textContent = formatTime(room.updated_at);
            
            const unreadCount = appState.unreadCounts.get(room.id) || 0;
            if (unreadCount > 0) {
                const unreadBadge = document.createElement('div');
                unreadBadge.className = 'unread-count';
                unreadBadge.textContent = unreadCount > 99 ? '99+' : unreadCount.toString();
                roomMeta.appendChild(unreadBadge);
            }
            
            roomMeta.appendChild(roomTime);
            
            roomElement.appendChild(roomIcon);
            roomElement.appendChild(roomInfo);
            roomElement.appendChild(roomMeta);
            
            roomElement.addEventListener('click', () => selectRoom(room.id));
            
            return roomElement;
        }
        
        async function selectRoom(roomId) {
            logSystem(`Selecting room: ${roomId}`);
            
            // Update UI
            document.querySelectorAll('.room-item').forEach(item => {
                item.classList.remove('active');
            });
            
            const roomElement = document.querySelector(`[data-room-id="${roomId}"]`);
            if (roomElement) {
                roomElement.classList.add('active');
            }
            
            // Update current room and persist it
            appState.currentRoom = roomId;
            localStorage.setItem('currentRoom', roomId);
            
            // Show chat interface
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('chatInterface').style.display = 'flex';
            
            // Update chat header
            const room = appState.rooms.get(roomId);
            if (room) {
                updateChatHeader(room);
            }
            
            // ✅ CONNECT TO ROOM-SPECIFIC WEBSOCKET FOR REAL-TIME MESSAGES
            await connectToRoomWebSocket(roomId);
            
            // Load messages for this room
            await loadRoomMessages(roomId);
            
            // Clear unread count
            appState.unreadCounts.set(roomId, 0);
            updateRoomsList();
        }
        
        function updateChatHeader(room) {
            const currentRoomIcon = document.getElementById('currentRoomIcon');
            const currentRoomIconText = document.getElementById('currentRoomIconText');
            const currentRoomName = document.getElementById('currentRoomName');
            const currentRoomStatus = document.getElementById('currentRoomStatus');
            
            if (currentRoomIcon) {
                currentRoomIcon.className = `room-icon ${room.type}`;
            }
            
            if (currentRoomIconText) {
                currentRoomIconText.textContent = room.type === 'direct' ? 'D' : 'G';
            }
            
            if (currentRoomName) {
                currentRoomName.textContent = getRoomDisplayName(room);
            }
            
            if (currentRoomStatus) {
                const memberCount = room.members ? room.members.length : 0;
                currentRoomStatus.textContent = room.type === 'direct' 
                    ? 'Direct conversation' 
                    : `${memberCount} members`;
            }
        }
        
        async function loadRoomMessages(roomId) {
            try {
                console.log('=== LOADING MESSAGES DEBUG ===');
                console.log('Room ID:', roomId);
                console.log('Current user:', appState.user);
                console.log('Access token exists:', !!appState.accessToken);
                
                logSystem(`Loading messages for room: ${roomId}`, 'info');
                
                const url = `http://localhost:8000/chat/rooms/${roomId}/messages`;
                console.log('API URL:', url);
                
                const response = await authenticatedFetch(url);
                console.log('Response status:', response.status);
                console.log('Response headers:', Object.fromEntries(response.headers.entries()));
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API Error Response:', errorText);
                    console.error('Failed to load messages:', {
                        status: response.status,
                        statusText: response.statusText,
                        body: errorText,
                        url: url
                    });
                    
                    // Show user-friendly message based on error
                    if (response.status === 403) {
                        logSystem('Access denied - you may not be a member of this room', 'error');
                    } else if (response.status === 404) {
                        logSystem('Room not found', 'error');
                    } else {
                        logSystem(`API error ${response.status}: ${errorText}`, 'error');
                    }
                    return;
                }
                
                const data = await response.json();
                console.log('Raw API response:', data);
                console.log('Response type:', typeof data);
                console.log('Is array:', Array.isArray(data));
                
                // Handle both direct array and object with messages property
                const messages = Array.isArray(data) ? data : (data.messages || []);
                console.log('Extracted messages:', messages);
                console.log('Messages count:', messages.length);
                
                if (Array.isArray(messages)) {
                    console.log(`✓ Received ${messages.length} messages for room ${roomId}`);
                    
                    // Debug each message
                    messages.forEach((msg, idx) => {
                        console.log(`Message ${idx + 1}:`, {
                            id: msg.id,
                            type: msg.message_type,
                            content: msg.content || '[file]',
                            sender: msg.sender_username,
                            created: msg.created_at
                        });
                    });
                    
                    appState.messages.set(roomId, messages);
                    displayMessages(messages);
                    logSystem(`Loaded ${messages.length} messages for room`, 'success');
                } else {
                    console.error('Invalid messages response format:', data);
                    logSystem('Invalid messages response format from server', 'error');
                }
                
                console.log('=== END LOADING MESSAGES DEBUG ===');
                
            } catch (error) {
                console.error('Error loading room messages:', error);
                console.error('Error stack:', error.stack);
                logSystem(`Failed to load messages: ${error.message}`, 'error');
            }
        }
        
        function displayMessages(messages) {
            console.log('displayMessages called with:', messages);
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.innerHTML = '';
            
            if (!Array.isArray(messages) || messages.length === 0) {
                console.log('No messages to display, showing empty state');
                messagesContainer.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #95a5a6;">
                        No messages yet<br>
                        <span style="font-size: 12px;">Start the conversation!</span>
                    </div>
                `;
                logSystem('No messages in current room', 'info');
                return;
            }
            
            console.log(`Displaying ${messages.length} messages`);
            messages.forEach((message, index) => {
                console.log(`Creating element for message ${index + 1}:`, message);
                const messageElement = createMessageElement(message);
                messagesContainer.appendChild(messageElement);
            });
            
            logSystem(`Displayed ${messages.length} messages in chat`, 'success');
            scrollToBottom();
        }
        
        function createMessageElement(message) {
            const messageContainer = document.createElement('div');
            messageContainer.className = `message-container ${message.sender_id === appState.user.id ? 'own-message' : 'other-message'}`;
            messageContainer.setAttribute('data-message-id', message.id);
            
            const messageBubble = document.createElement('div');
            messageBubble.className = 'message-bubble';
            
            // Handle both 'type' and 'message_type' fields for compatibility
            const messageType = message.message_type || message.type;
            
            // Message content area
            const messageContentArea = document.createElement('div');
            messageContentArea.className = 'message-content-area';
            
            if (messageType === 'text') {
                const textContent = document.createElement('div');
                textContent.className = 'text-content';
                textContent.textContent = message.content;
                messageContentArea.appendChild(textContent);
            } else if (messageType === 'file' || messageType === 'image') {
                messageContentArea.appendChild(createFileMessageContent(message));
            } else {
                // Fallback for other message types
                const textContent = document.createElement('div');
                textContent.className = 'text-content';
                textContent.textContent = message.content || 'Message';
                messageContentArea.appendChild(textContent);
            }
            
            // Message footer with time and status
            const messageFooter = document.createElement('div');
            messageFooter.className = 'message-footer';
            
            const messageTime = document.createElement('span');
            messageTime.className = 'message-time';
            messageTime.textContent = formatTime(message.created_at);
            
            messageFooter.appendChild(messageTime);
            
            // Add status indicators for own messages (WhatsApp style)
            if (message.sender_id === appState.user.id) {
                const statusIcon = document.createElement('span');
                statusIcon.className = 'status-icon';
                
                // Determine status based on message status or default to sent
                const status = message.status || 'sent';
                switch(status) {
                    case 'sent':
                        statusIcon.innerHTML = '✓'; // Single tick
                        statusIcon.className += ' status-sent';
                        break;
                    case 'delivered':
                        statusIcon.innerHTML = '✓✓'; // Double tick (gray)
                        statusIcon.className += ' status-delivered';
                        break;
                    case 'read':
                        statusIcon.innerHTML = '✓✓'; // Double tick (blue)
                        statusIcon.className += ' status-read';
                        break;
                    default:
                        statusIcon.innerHTML = '🕐'; // Clock for pending
                        statusIcon.className += ' status-pending';
                }
                
                messageFooter.appendChild(statusIcon);
            }
            
            messageBubble.appendChild(messageContentArea);
            messageBubble.appendChild(messageFooter);
            messageContainer.appendChild(messageBubble);
            
            return messageContainer;
        }
        
        function createFileMessageContent(message) {
            const fileContainer = document.createElement('div');
            fileContainer.className = 'file-message';
            
            const fileIcon = document.createElement('div');
            fileIcon.className = 'file-icon';
            
            // Enhanced file icon based on file type
            const fileName = message.file_name || 'Unknown file';
            const extension = fileName.split('.').pop().toLowerCase();
            
            let iconText = '📎';
            if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'].includes(extension)) {
                iconText = '🖼️';
            } else if (['pdf'].includes(extension)) {
                iconText = '📄';
            } else if (['doc', 'docx'].includes(extension)) {
                iconText = '📝';
            } else if (['zip', 'rar', '7z'].includes(extension)) {
                iconText = '📦';
            } else if (['mp4', 'avi', 'mov', 'wmv'].includes(extension)) {
                iconText = '🎬';
            } else if (['mp3', 'wav', 'flac', 'aac'].includes(extension)) {
                iconText = '🎵';
            }
            
            fileIcon.textContent = iconText;
            
            const fileInfo = document.createElement('div');
            fileInfo.className = 'file-info';
            
            const fileName_el = document.createElement('div');
            fileName_el.className = 'file-name';
            fileName_el.textContent = fileName;
            fileName_el.title = fileName; // Tooltip for long names
            
            const fileSize = document.createElement('div');
            fileSize.className = 'file-size';
            fileSize.textContent = message.file_size ? formatBytes(message.file_size) : '';
            
            fileInfo.appendChild(fileName_el);
            if (message.file_size) {
                fileInfo.appendChild(fileSize);
            }
            
            const fileActions = document.createElement('div');
            fileActions.className = 'file-actions';
            
            const downloadBtn = document.createElement('button');
            downloadBtn.className = 'btn-small btn-primary';
            downloadBtn.textContent = '⬇️ Download';
            downloadBtn.onclick = () => downloadFile(message.file_path, message.file_name);
            
            fileActions.appendChild(downloadBtn);
            
            fileContainer.appendChild(fileIcon);
            fileContainer.appendChild(fileInfo);
            fileContainer.appendChild(fileActions);
            
            return fileContainer;
        }
        
        // WebSocket message handlers
        function addMessageToChat(data) {
            if (data.message && appState.currentRoom === data.message.room_id) {
                // Add the new message to the current room
                const messageElement = createMessageElement(data.message);
                const messagesContainer = document.getElementById('messagesContainer');
                messagesContainer.appendChild(messageElement);
                scrollToBottom();
                
                // Update room last message
                const room = appState.rooms.get(data.message.room_id);
                if (room) {
                    room.last_message = data.message.content || 'File attachment';
                    room.updated_at = data.message.created_at;
                    updateRoomsList();
                }
                
                logSystem(`New message received in room ${data.message.room_id}`, 'info');
            }
        }
        
        function addFileMessageToChat(data) {
            if (data.message && appState.currentRoom === data.message.room_id) {
                // Add the new file message to the current room
                const messageElement = createMessageElement(data.message);
                const messagesContainer = document.getElementById('messagesContainer');
                messagesContainer.appendChild(messageElement);
                scrollToBottom();
                
                // Update room last message
                const room = appState.rooms.get(data.message.room_id);
                if (room) {
                    room.last_message = `📎 ${data.message.file_name}`;
                    room.updated_at = data.message.created_at;
                    updateRoomsList();
                }
                
                logSystem(`New file message received: ${data.message.file_name}`, 'success');
            }
        }
        
        function handleRoomCreated(data) {
            logSystem(`New room created: ${data.room_id}`, 'info');
            // Reload rooms to include the new one
            loadChatRooms();
        }
        
        function handleUserEvent(data) {
            logSystem(`User event: ${data.type} - ${data.message}`, 'info');
        }
        
        async function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const content = messageInput.value.trim();
            
            if (!content) {
                return;
            }
            
            // Ensure we have a room - create one if needed
            if (!appState.currentRoom) {
                await ensureDirectMessageRoom();
                if (!appState.currentRoom) {
                    logSystem('No room available to send message', 'error');
                    return;
                }
            }
            
            // Clear input immediately for better UX
            messageInput.value = '';
            autoResizeTextarea({ target: messageInput });
            
            try {
                // Create optimistic message for immediate display
                const tempMessage = {
                    id: 'temp-' + Date.now(),
                    content: content,
                    message_type: 'text',
                    sender_id: appState.user.id,
                    sender_username: appState.user.username,
                    created_at: new Date().toISOString(),
                    status: 'pending'
                };
                
                // Add to local messages immediately
                const roomMessages = appState.messages.get(appState.currentRoom) || [];
                roomMessages.push(tempMessage);
                appState.messages.set(appState.currentRoom, roomMessages);
                
                // Display the optimistic message
                const messageElement = createMessageElement(tempMessage);
                const messagesContainer = document.getElementById('messagesContainer');
                messagesContainer.appendChild(messageElement);
                scrollToBottom();
                
                // Send via HTTP API
                const response = await authenticatedFetch(`http://localhost:8000/chat/rooms/${appState.currentRoom}/messages`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        content: content,
                        reply_to_id: null
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    // Update status to sent
                    updateMessageStatus(tempMessage.id, 'sent');
                    
                    // WebSocket will handle real-time delivery and status updates
                    logSystem(`Message sent successfully: ${result.message_id}`, 'info');
                
                // Force reload messages to ensure they appear
                setTimeout(async () => {
                    console.log('Auto-refreshing messages after send...');
                    await loadRoomMessages(appState.currentRoom);
                }, 1000);
                } else {
                    throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                }
                
            } catch (error) {
                logSystem(`Failed to send message: ${error.message}`, 'error');
                
                // Update status to failed
                updateMessageStatus('temp-' + (Date.now() - 1000), 'failed');
            }
        }
        
        async function ensureDirectMessageRoom() {
            try {
                // Try to get existing rooms first
                const roomsResponse = await authenticatedFetch('http://localhost:8000/chat/rooms');
                if (roomsResponse.ok) {
                    const roomsData = await roomsResponse.json();
                    const rooms = roomsData.rooms || [];
                    
                    // Look for an existing direct message room
                    const directRoom = rooms.find(room => room.type === 'direct');
                    if (directRoom) {
                        appState.currentRoom = directRoom.id;
                        updateChatHeader(directRoom);
                        return;
                    }
                }
                
                // Create a new direct message room if none exists
                const createResponse = await authenticatedFetch('http://localhost:8000/chat/rooms', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        type: 'direct',
                        members: [], // Just the current user
                        name: null
                    })
                });
                
                if (createResponse.ok) {
                    const newRoom = await createResponse.json();
                    appState.currentRoom = newRoom.id;
                    updateChatHeader(newRoom);
                    logSystem(`Created new chat room: ${newRoom.id}`, 'info');
                } else {
                    throw new Error(`Failed to create room: ${createResponse.status}`);
                }
                
            } catch (error) {
                logSystem(`Failed to ensure room: ${error.message}`, 'error');
            }
        }
        
        function updateMessageStatus(messageId, newStatus) {
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageElement) {
                const statusIcon = messageElement.querySelector('.status-icon');
                if (statusIcon) {
                    statusIcon.className = `status-icon status-${newStatus}`;
                    
                    switch(newStatus) {
                        case 'sent':
                            statusIcon.innerHTML = '✓';
                            break;
                        case 'delivered':
                            statusIcon.innerHTML = '✓✓';
                            statusIcon.classList.add('status-delivered');
                            break;
                        case 'read':
                            statusIcon.innerHTML = '✓✓';
                            statusIcon.classList.add('status-read');
                            break;
                        case 'failed':
                            statusIcon.innerHTML = '❌';
                            statusIcon.classList.add('status-failed');
                            break;
                        default:
                            statusIcon.innerHTML = '🕐';
                    }
                }
            }
        }
        
        // Event Handlers
        function handleMessageInputKeydown(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        }
        
        function autoResizeTextarea(e) {
            const textarea = e.target;
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 100) + 'px';
        }
        
        function handleChatTypeChange() {
            const chatType = document.querySelector('input[name="chatType"]:checked').value;
            const directSection = document.getElementById('directChatSection');
            const groupSection = document.getElementById('groupChatSection');
            
            if (chatType === 'direct') {
                directSection.style.display = 'block';
                groupSection.style.display = 'none';
            } else {
                directSection.style.display = 'none';
                groupSection.style.display = 'block';
            }
        }
        
        function handleChunkModeChange() {
            const chunkMode = document.querySelector('input[name="chunkMode"]:checked').value;
            const manualSection = document.getElementById('manualChunkSection');
            
            if (chunkMode === 'manual') {
                manualSection.style.display = 'block';
            } else {
                manualSection.style.display = 'none';
            }
        }
        
        function handleRoomSearch(e) {
            const searchTerm = e.target.value.toLowerCase();
            const roomItems = document.querySelectorAll('.room-item');
            
            roomItems.forEach(item => {
                const roomName = item.querySelector('.room-name').textContent.toLowerCase();
                const lastMessage = item.querySelector('.room-last-message').textContent.toLowerCase();
                
                if (roomName.includes(searchTerm) || lastMessage.includes(searchTerm)) {
                    item.style.display = 'flex';
                } else {
                    item.style.display = 'none';
                }
            });
        }
        
        // Dialog Functions
        function showNewChatDialog() {
            document.getElementById('newChatDialog').style.display = 'flex';
        }
        
        function hideNewChatDialog() {
            document.getElementById('newChatDialog').style.display = 'none';
        }
        
        function showFileUploadDialog() {
            if (!appState.currentRoom) {
                alert('Please select a chat room first');
                return;
            }
            
            // Test network speed for smart chunking
            detectNetworkSpeedAndAdjustChunks();
            
            document.getElementById('fileUploadDialog').style.display = 'flex';
        }
        
        function hideFileUploadDialog() {
            document.getElementById('fileUploadDialog').style.display = 'none';
        }
        
        async function createNewChat() {
            const chatType = document.querySelector('input[name="chatType"]:checked').value;
            
            try {
                console.log('=== CREATE CHAT DEBUG ===');
                console.log('Chat type:', chatType);
                console.log('Current user:', appState.user);
                
                let roomData;
                
                if (chatType === 'direct') {
                    const email = document.getElementById('directUserEmail').value.trim();
                    console.log('Target email:', email);
                    
                    if (!email) {
                        alert('Please enter a user email');
                        return;
                    }
                    
                    // Check if direct chat already exists
                    const existingRoom = Array.from(appState.rooms.values()).find(room => 
                        room.type === 'direct' && 
                        room.members && room.members.some(m => {
                            const memberEmail = typeof m === 'string' ? m : m.email;
                            return memberEmail === email;
                        })
                    );
                    
                    if (existingRoom) {
                        selectRoom(existingRoom.id);
                        hideNewChatDialog();
                        return;
                    }
                    
                    roomData = {
                        type: 'direct',
                        name: null, // Direct chats don't need names
                        members: [email] // Single participant for direct chat
                    };
                } else {
                    const name = document.getElementById('groupChatName').value.trim();
                    const emails = document.getElementById('groupMemberEmails').value
                        .split(',')
                        .map(e => e.trim())
                        .filter(e => e);
                    
                    if (!name) {
                        alert('Please enter a group name');
                        return;
                    }
                    
                    roomData = {
                        type: 'group',
                        name: name,
                        members: emails // Array of member emails
                    };
                }
                
                const response = await authenticatedFetch('http://localhost:8000/chat/rooms', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(roomData)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server response error:', {
                        status: response.status,
                        statusText: response.statusText,
                        body: errorText
                    });
                    
                    let errorDetail;
                    try {
                        const errorJson = JSON.parse(errorText);
                        errorDetail = errorJson.detail || errorJson.message || errorText;
                    } catch {
                        errorDetail = errorText || `HTTP ${response.status}: ${response.statusText}`;
                    }
                    
                    throw new Error(errorDetail);
                }
                
                const newRoom = await response.json();
                console.log('New room created:', newRoom);
                console.log('Room members:', newRoom.members);
                console.log('Room ID:', newRoom.id);
                
                appState.rooms.set(newRoom.id, newRoom);
                updateRoomsList();
                
                console.log('Selecting newly created room...');
                await selectRoom(newRoom.id);
                hideNewChatDialog();
                
                logSystem(`Created new ${chatType} chat: ${newRoom.name || newRoom.id}`, 'success');
                console.log('=== END CREATE CHAT DEBUG ===');
                
            } catch (error) {
                console.error('Chat creation error:', error);
                const errorMessage = typeof error === 'object' && error.message ? error.message : 
                                   typeof error === 'string' ? error : 
                                   JSON.stringify(error);
                logSystem(`Failed to create chat: ${errorMessage}`, 'error');
                alert(`Failed to create chat: ${errorMessage}`);
            }
        }
        
        // Network & File Functions
        async function testNetworkSpeed() {
            const statusText = document.getElementById('networkStatusText');
            const suggestedChunkSize = document.getElementById('suggestedChunkSize');
            
            try {
                statusText.textContent = 'Testing network speed...';
                
                const startTime = Date.now();
                const response = await fetch('http://localhost:8000/speedtest/1024'); // 1MB test
                const endTime = Date.now();
                
                if (response.ok) {
                    const speed = (1024 * 1000) / (endTime - startTime); // KB/s
                    appState.networkSpeed = speed;
                    
                    // Calculate optimal chunk size
                    let optimalChunkSize;
                    if (speed < 100) {
                        optimalChunkSize = 262144; // 256KB
                    } else if (speed < 500) {
                        optimalChunkSize = 524288; // 512KB
                    } else if (speed < 1000) {
                        optimalChunkSize = 1048576; // 1MB
                    } else if (speed < 2000) {
                        optimalChunkSize = 2097152; // 2MB
                    } else {
                        optimalChunkSize = 4194304; // 4MB
                    }
                    
                    appState.suggestedChunkSize = optimalChunkSize;
                    
                    statusText.textContent = `${formatBytes(speed * 1000)}/s`;
                    suggestedChunkSize.textContent = formatBytes(optimalChunkSize);
                    
                } else {
                    throw new Error('Speed test failed');
                }
                
            } catch (error) {
                statusText.textContent = 'Unable to test network';
                suggestedChunkSize.textContent = '1 MB (default)';
                appState.suggestedChunkSize = 1048576;
            }
        }
        
        function triggerFileUpload() {
            showFileUploadDialog();
        }
        
        function handleChatFileSelect() {
            const file = document.getElementById('hiddenFileInput').files[0];
            const chatFileInput = document.getElementById('chatFileInput');
            
            if (file) {
                // Copy to visible input
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                chatFileInput.files = dataTransfer.files;
                
                updateChatFileInfo(file);
            }
        }
        
        async function updateChatFileInfo(file) {
            const fileInfo = document.getElementById('chatFileInfo');
            const startBtn = document.getElementById('startFileUploadBtn');
            
            if (file) {
                appState.selectedFile = file;
                
                // Detect network speed and adjust suggested chunk size
                await detectNetworkSpeedAndAdjustChunks();
                
                const chunkSize = document.querySelector('input[name="chunkMode"]:checked').value === 'auto' 
                    ? appState.suggestedChunkSize 
                    : parseInt(document.getElementById('manualChunkSize').value);
                
                const totalChunks = Math.ceil(file.size / chunkSize);
                const networkQuality = getNetworkQuality();
                
                fileInfo.innerHTML = `
                    <h4>File: ${file.name}</h4>
                    <p><strong>Size:</strong> ${formatBytes(file.size)}</p>
                    <p><strong>Type:</strong> ${file.type || 'Unknown'}</p>
                    <p><strong>Network:</strong> ${networkQuality}</p>
                    <p><strong>Chunks:</strong> ${totalChunks} x ${formatBytes(chunkSize)} each</p>
                `;
                
                // Update suggested chunk size display
                document.getElementById('suggestedChunkSize').textContent = 
                    `${formatBytes(appState.suggestedChunkSize)} (${Math.ceil(file.size / appState.suggestedChunkSize)} chunks)`;
                fileInfo.style.display = 'block';
                startBtn.disabled = false;
            } else {
                fileInfo.style.display = 'none';
                startBtn.disabled = true;
            }
        }
        
        async function startChatFileUpload() {
            if (!appState.selectedFile) {
                alert('Please select a file first.');
                return;
            }
            
            // Ensure we have a room
            if (!appState.currentRoom) {
                await ensureDirectMessageRoom();
                if (!appState.currentRoom) {
                    alert('Unable to create chat room. Please try again.');
                    return;
                }
            }
            
            const file = appState.selectedFile;
            const chunkMode = document.querySelector('input[name="chunkMode"]:checked').value;
            const chunkSize = chunkMode === 'auto' 
                ? appState.suggestedChunkSize 
                : parseInt(document.getElementById('manualChunkSize').value);
            
            // Close the upload dialog immediately for better UX
            hideFileUploadDialog();
            
            try {
                logSystem(`Starting file upload: ${file.name}`, 'info');
                
                // Calculate file hash
                const fileHash = await calculateFileHash(file);
                
                // Upload file using chunked upload (progress will show in chat)
                await uploadFileToChat(file, chunkSize, fileHash);
                
                logSystem(`File uploaded successfully: ${file.name}`, 'success');
                
            } catch (error) {
                logSystem(`File upload failed: ${error.message}`, 'error');
                
                // Show error message in chat as well
                const messagesContainer = document.getElementById('messagesContainer');
                const errorDiv = document.createElement('div');
                errorDiv.className = 'upload-error';
                errorDiv.style.cssText = 'padding: 12px; margin: 10px 0; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; color: #721c24;';
                errorDiv.innerHTML = `❌ Failed to upload ${file.name}: ${error.message}`;
                messagesContainer.appendChild(errorDiv);
                scrollToBottom();
            }
        }
        
        async function uploadFileToChat(file, chunkSize, fileHash) {
            // Ensure we have a room for file upload
            if (!appState.currentRoom) {
                await ensureDirectMessageRoom();
                if (!appState.currentRoom) {
                    throw new Error('No room available for file upload');
                }
            }
            
            const totalChunks = Math.ceil(file.size / chunkSize);
            
            logSystem(`Uploading ${file.name} to room ${appState.currentRoom} in ${totalChunks} chunks`, 'info');
            
            // Create progress display in the messages container using the new styles
            const progressContainer = document.createElement('div');
            progressContainer.className = 'upload-progress-container';
            progressContainer.innerHTML = `
                <div class="upload-status">${file.name}</div>
                <div class="progress-bar">
                    <div id="chatUploadProgress" class="progress-fill" style="width: 0%;">0%</div>
                </div>
                <div id="chatUploadStatus" class="progress-status">Preparing upload...</div>
            `;
            
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.appendChild(progressContainer);
            scrollToBottom();
            
            try {
                // Start upload session (chat endpoints expect JSON, not FormData)
                document.getElementById('chatUploadStatus').textContent = 'Starting upload session...';
                
                const startRequest = {
                    filename: file.name,
                    total_chunks: totalChunks,
                    file_size: file.size,
                    file_hash: fileHash
                };

                const startResponse = await authenticatedFetch(`http://localhost:8000/chat/rooms/${appState.currentRoom}/files/start`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(startRequest)
                });

            if (!startResponse.ok) {
                const errorText = await startResponse.text();
                console.error('Start upload error:', {
                    status: startResponse.status,
                    statusText: startResponse.statusText,
                    body: errorText
                });
                throw new Error(`Failed to start file upload: ${startResponse.status} ${startResponse.statusText}`);
            }
            
            const startResult = await startResponse.json();
            const fileId = startResult.file_id; // Use the file_id returned by the server
            
                // Upload chunks
                for (let chunkNumber = 0; chunkNumber < totalChunks; chunkNumber++) {
                    const start = chunkNumber * chunkSize;
                    const end = Math.min(start + chunkSize, file.size);
                    const chunk = file.slice(start, end);
                    const chunkHash = await calculateChunkHash(chunk);
                    
                    // Update progress with better visual feedback
                    const progress = ((chunkNumber + 1) / totalChunks) * 100;
                    const progressFill = document.getElementById('chatUploadProgress');
                    const progressStatus = document.getElementById('chatUploadStatus');
                    
                    progressFill.style.width = `${progress}%`;
                    progressFill.textContent = `${progress.toFixed(0)}%`;
                    progressStatus.textContent = `Chunk ${chunkNumber + 1} of ${totalChunks} • ${formatBytes(chunk.size)} • ${progress.toFixed(1)}% complete`;
                    
                    logSystem(`Uploading chunk ${chunkNumber + 1}/${totalChunks} (${formatBytes(chunk.size)})`, 'info');
                    
                    const chunkFormData = new FormData();
                    chunkFormData.append('file_id', fileId);
                    chunkFormData.append('chunk_number', chunkNumber.toString());
                    chunkFormData.append('total_chunks', totalChunks.toString());
                    chunkFormData.append('chunk_hash', chunkHash);
                    chunkFormData.append('chunk', chunk);
                    
                    const chunkResponse = await authenticatedFetch(`http://localhost:8000/chat/rooms/${appState.currentRoom}/files/chunk`, {
                        method: 'POST',
                        body: chunkFormData
                    });
                    
                    if (!chunkResponse.ok) {
                        throw new Error(`Failed to upload chunk ${chunkNumber}`);
                    }
                    
                    logSystem(`Uploaded chunk ${chunkNumber + 1}/${totalChunks} successfully`, 'success');
                }
                
                // Show completion progress
                document.getElementById('chatUploadProgress').style.width = '100%';
                document.getElementById('chatUploadProgress').textContent = '100%';
                document.getElementById('chatUploadStatus').textContent = 'Finalizing upload...';
            
                // Complete upload
                const completeFormData = new FormData();
                completeFormData.append('file_id', fileId);
                completeFormData.append('expected_hash', fileHash);
                
                const completeResponse = await authenticatedFetch(`http://localhost:8000/chat/rooms/${appState.currentRoom}/files/complete`, {
                    method: 'POST',
                    body: completeFormData
                });
                
                if (!completeResponse.ok) {
                    throw new Error('Failed to complete file upload');
                }
                
                const result = await completeResponse.json();
                console.log('File upload completion result:', result);
                
                // Update progress to show success
                document.getElementById('chatUploadProgress').style.width = '100%';
                document.getElementById('chatUploadProgress').textContent = '✓ Complete';
                document.getElementById('chatUploadStatus').textContent = 'Upload completed successfully!';
                
                // Keep progress visible for a moment, then remove
                setTimeout(() => {
                    progressContainer.remove();
                }, 1500);
                
                logSystem(`File uploaded successfully: ${file.name}`, 'success');
                
                // Instead of reloading all messages, directly add the file message to chat
                if (result.message_id && result.file_info) {
                    console.log('Creating file message with data:', result);
                    
                    // Create a file message object
                    const fileMessage = {
                        id: result.message_id,
                        sender_id: appState.user.id,
                        sender_username: appState.user.username || appState.user.email,
                        message_type: 'file',
                        file_name: result.file_info.original_filename,
                        file_size: result.file_info.file_size,
                        file_path: result.file_info.file_path,
                        file_hash: result.file_info.file_hash,
                        created_at: new Date().toISOString(),
                        room_id: appState.currentRoom
                    };
                    
                    console.log('File message object created:', fileMessage);
                    
                    // Add to chat immediately
                    try {
                        const messageElement = createMessageElement(fileMessage);
                        const messagesContainer = document.getElementById('messagesContainer');
                        messagesContainer.appendChild(messageElement);
                        scrollToBottom();
                        
                        // Update local messages state
                        const roomMessages = appState.messages.get(appState.currentRoom) || [];
                        roomMessages.push(fileMessage);
                        appState.messages.set(appState.currentRoom, roomMessages);
                        
                        logSystem(`File message added to chat: ${fileMessage.file_name}`, 'success');
                    } catch (error) {
                        console.error('Error creating file message element:', error);
                        logSystem(`Error displaying file message: ${error.message}`, 'error');
                    }
                } else {
                    console.warn('Missing message_id or file_info in result:', result);
                    logSystem('File uploaded but message data incomplete', 'warning');
                }
                
                return result;
                
            } catch (error) {
                // Remove progress container on error
                if (progressContainer.parentNode) {
                    progressContainer.remove();
                }
                logSystem(`File upload failed: ${getDetailedErrorMessage(error)}`, 'error');
                throw error;
            }
        }

        // Network Detection Functions
        async function detectNetworkSpeedAndAdjustChunks() {
            try {
                const startTime = performance.now();
                
                // Test with a small request to the backend
                const testResponse = await fetch('http://localhost:8000/health', {
                    method: 'GET',
                    cache: 'no-cache'
                });
                
                const endTime = performance.now();
                const latency = endTime - startTime;
                
                // Estimate connection quality based on latency and connection info
                let quality = 'good';
                let suggestedSize = 1048576; // 1MB default
                
                if (navigator.connection) {
                    const connection = navigator.connection;
                    const downlink = connection.downlink; // Mbps
                    const effectiveType = connection.effectiveType;
                    
                    if (effectiveType === 'slow-2g' || downlink < 0.5) {
                        quality = 'poor';
                        suggestedSize = 262144; // 256KB
                    } else if (effectiveType === '2g' || downlink < 1.5) {
                        quality = 'fair';
                        suggestedSize = 524288; // 512KB  
                    } else if (effectiveType === '3g' || downlink < 5) {
                        quality = 'good';
                        suggestedSize = 1048576; // 1MB
                    } else {
                        quality = 'excellent';
                        suggestedSize = 2097152; // 2MB
                    }
                } else if (latency > 1000) {
                    quality = 'poor';
                    suggestedSize = 262144; // 256KB
                } else if (latency > 500) {
                    quality = 'fair';
                    suggestedSize = 524288; // 512KB
                } else if (latency > 200) {
                    quality = 'good';
                    suggestedSize = 1048576; // 1MB
                } else {
                    quality = 'excellent';
                    suggestedSize = 2097152; // 2MB
                }
                
                appState.networkQuality = quality;
                appState.suggestedChunkSize = suggestedSize;
                appState.networkLatency = latency;
                
                logSystem(`Network detected: ${quality} (${Math.round(latency)}ms latency)`, 'info');
                
            } catch (error) {
                logSystem(`Network detection failed: ${error.message}`, 'warning');
                appState.networkQuality = 'unknown';
                appState.suggestedChunkSize = 1048576; // 1MB default
            }
        }

        function getNetworkQuality() {
            const quality = appState.networkQuality || 'unknown';
            const latency = appState.networkLatency || 0;
            
            if (navigator.connection) {
                const connection = navigator.connection;
                return `${quality} (${connection.effectiveType || 'unknown'}, ${Math.round(latency)}ms)`;
            }
            
            return `${quality} (${Math.round(latency)}ms)`;
        }
        
        // Utility Functions
        function updateConnectionStatus(status) {
            appState.connectionStatus = status;
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionText');
            
            switch (status) {
                case 'connected':
                    dot.className = 'status-dot connected';
                    text.textContent = 'Connected';
                    break;
                case 'connecting':
                    dot.className = 'status-dot connecting';
                    text.textContent = 'Connecting...';
                    break;
                case 'disconnected':
                    dot.className = 'status-dot disconnected';
                    text.textContent = 'Disconnected';
                    break;
            }
        }
        
        function logSystem(message, level = 'info') {
            const systemLogs = document.getElementById('systemLogs');
            const now = new Date();
            const timestamp = now.toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${level}`;
            logEntry.innerHTML = `
                <span class="log-timestamp">[${timestamp}]</span>
                <span class="log-message">${message}</span>
            `;
            
            systemLogs.appendChild(logEntry);
            systemLogs.scrollTop = systemLogs.scrollHeight;
            
            // Update badge if not on logs tab
            const logsTab = document.getElementById('logsTab');
            const badge = document.getElementById('logsBadge');
            if (logsTab && !logsTab.classList.contains('active')) {
                let count = parseInt(badge.textContent) || 0;
                count++;
                badge.textContent = count;
                badge.style.display = 'inline';
            }
            
            // Keep only last 200 entries for better history
            while (systemLogs.children.length > 200) {
                systemLogs.removeChild(systemLogs.firstChild);
            }
        }
        
        function formatTime(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'now';
            if (diffMins < 60) return `${diffMins}m`;
            if (diffHours < 24) return `${diffHours}h`;
            if (diffDays < 7) return `${diffDays}d`;
            
            return date.toLocaleDateString();
        }
        
        function scrollToBottom() {
            const container = document.getElementById('messagesContainer');
            container.scrollTop = container.scrollHeight;
        }
        
        async function refreshCurrentRoomMessages() {
            if (appState.currentRoom) {
                console.log('=== MANUAL REFRESH DEBUG ===');
                console.log('Current room:', appState.currentRoom);
                console.log('Room exists in appState.rooms:', appState.rooms.has(appState.currentRoom));
                console.log('Current user:', appState.user);
                console.log('Access token exists:', !!appState.accessToken);
                
                logSystem('Refreshing current room messages...', 'info');
                await loadRoomMessages(appState.currentRoom);
                console.log('=== END MANUAL REFRESH DEBUG ===');
            } else {
                logSystem('No active room to refresh', 'warning');
                console.log('No currentRoom set. Available rooms:', Array.from(appState.rooms.keys()));
                alert('No active room selected. Please wait for room initialization.');
            }
        }
        
        async function sendTestMessage() {
            if (!appState.currentRoom) {
                alert('No room selected');
                return;
            }
            
            const testContent = `Test message from frontend - ${new Date().toLocaleTimeString()}`;
            console.log('Sending test message:', testContent);
            
            try {
                const response = await sendMessage(testContent);
                if (response) {
                    console.log('✅ Test message sent successfully');
                    logSystem(`Test message sent: ${testContent}`, 'success');
                } else {
                    console.log('❌ Test message failed');
                    logSystem('Failed to send test message', 'error');
                }
            } catch (error) {
                console.error('Error sending test message:', error);
                logSystem(`Test message error: ${error.message}`, 'error');
            }
        }
        
        // Debug function to test API directly
        async function testMessagesAPI() {
            if (!appState.currentRoom) {
                alert('No active room selected');
                return;
            }
            
            console.log('=== DIRECT API TEST ===');
            try {
                // Test 1: Basic messages API
                const url = `http://localhost:8000/chat/rooms/${appState.currentRoom}/messages`;
                console.log('Testing URL:', url);
                console.log('Authorization header:', `Bearer ${appState.accessToken?.substring(0, 20)}...`);
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${appState.accessToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                console.log('Raw response status:', response.status);
                console.log('Raw response headers:', Object.fromEntries(response.headers.entries()));
                
                const text = await response.text();
                console.log('Raw response text:', text);
                
                if (response.ok) {
                    try {
                        const data = JSON.parse(text);
                        console.log('Parsed response data:', data);
                        
                        // Test 2: Try to send a test message if no messages exist
                        if (!data.messages || data.messages.length === 0) {
                            console.log('--- No messages found, trying to send test message ---');
                            
                            const testMessage = {
                                content: `Test message from API test - ${new Date().toLocaleTimeString()}`,
                                reply_to_id: null
                            };
                            
                            const sendResponse = await fetch(`http://localhost:8000/chat/rooms/${appState.currentRoom}/messages`, {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${appState.accessToken}`,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(testMessage)
                            });
                            
                            console.log('Send message response status:', sendResponse.status);
                            const sendText = await sendResponse.text();
                            console.log('Send message response:', sendText);
                            
                            if (sendResponse.ok) {
                                console.log('✅ Test message sent successfully');
                                // Wait and check again
                                setTimeout(async () => {
                                    console.log('--- Rechecking messages after send ---');
                                    const recheckResponse = await fetch(url, {
                                        method: 'GET',
                                        headers: {
                                            'Authorization': `Bearer ${appState.accessToken}`,
                                            'Content-Type': 'application/json'
                                        }
                                    });
                                    const recheckData = await recheckResponse.json();
                                    console.log('Messages after sending:', recheckData);
                                }, 1000);
                            } else {
                                console.log('❌ Failed to send test message:', sendText);
                            }
                        }
                        
                        alert(`API Test Success! Found ${data.messages?.length || 0} messages. Check console for details.`);
                    } catch (e) {
                        console.error('JSON parse error:', e);
                        alert('API returned non-JSON response. Check console.');
                    }
                } else {
                    alert(`API Error ${response.status}: ${text}`);
                }
            } catch (error) {
                console.error('API test error:', error);
                alert(`API Test Failed: ${error.message}`);
            }
            console.log('=== END DIRECT API TEST ===');
        }
        
        // Comprehensive debug function
        async function debugChatSystem() {
            console.log('=== COMPREHENSIVE CHAT DEBUG ===');
            
            console.log('1. User State:');
            console.log('   - User:', appState.user);
            console.log('   - Access Token:', appState.accessToken ? 'Present' : 'Missing');
            console.log('   - Logged In:', appState.isLoggedIn);
            
            console.log('2. Room State:');
            console.log('   - Current Room:', appState.currentRoom);
            console.log('   - Total Rooms:', appState.rooms.size);
            console.log('   - Rooms:', Object.fromEntries(appState.rooms));
            
            console.log('3. WebSocket State:');
            console.log('   - WebSocket exists:', !!appState.chatWs);
            console.log('   - WebSocket state:', appState.chatWs ? appState.chatWs.readyState : 'No WebSocket');
            console.log('   - Connection status:', appState.chatWs?.readyState === WebSocket.OPEN ? 'CONNECTED' : 'DISCONNECTED');
            
            if (appState.currentRoom) {
                console.log('4. Current Room Details:');
                const room = appState.rooms.get(appState.currentRoom);
                console.log('   - Room object:', room);
                console.log('   - Room members:', room?.members);
                console.log('   - Messages in local state:', appState.messages.get(appState.currentRoom)?.length || 0);
                
                console.log('5. Testing Messages API:');
                await testMessagesAPI();
            }
            
            console.log('=== END COMPREHENSIVE DEBUG ===');
        }
        
        function clearCurrentChatMessages() {
            if (appState.currentRoom) {
                document.getElementById('messagesContainer').innerHTML = '';
                appState.messages.set(appState.currentRoom, []);
                logSystem('Messages cleared from current room', 'info');
            }
        }
        
        async function downloadFile(filePath, fileName) {
            try {
                const response = await authenticatedFetch(`http://localhost:8000/upload/download/${encodeURIComponent(fileName)}`);
                
                if (!response.ok) {
                    throw new Error('File not found');
                }
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                logSystem(`Downloaded file: ${fileName}`, 'success');
                
            } catch (error) {
                logSystem(`Download failed: ${error.message}`, 'error');
                alert(`Download failed: ${error.message}`);
            }
        }
        
        // Legacy compatibility functions (keep existing file upload working)
        function handleFileSelect() { /* Legacy compatibility - no-op */ }
        function startRealUpload() { /* Legacy compatibility - no-op */ }
        function pauseUpload() { /* Legacy compatibility - no-op */ }
        function resumeUpload() { /* Legacy compatibility - no-op */ }
        function cancelUpload() { /* Legacy compatibility - no-op */ }
        function downloadUploadedFile() { /* Legacy compatibility - no-op */ }
        function connectWebSocket() { /* Legacy compatibility - no-op */ }
        function disconnectWebSocket() { 
            stopHeartbeat();
            if (appState.chatWs) {
                appState.chatWs.close();
                appState.chatWs = null;
            }
            if (appState.fileWs) {
                appState.fileWs.close();
                appState.fileWs = null;
            }
            updateConnectionStatus('disconnected');
        }
        function clearMessages() { clearCurrentChatMessages(); }
        function sendPing() { 
            if (appState.chatWs && appState.chatWs.readyState === WebSocket.OPEN) {
                appState.chatWs.send(JSON.stringify({ type: 'ping' }));
            }
        }
        function simulateUpload() { /* Legacy compatibility - no-op */ }
        
        // Initialize application
        window.onload = function() {
            logSystem('SmartFileTransfer Chat Application starting...');
            
            initAuth();
            
            // Setup file input change handler
            document.getElementById('chatFileInput').addEventListener('change', function() {
                updateChatFileInfo(this.files[0]);
            });
            
            document.getElementById('hiddenFileInput').addEventListener('change', handleChatFileSelect);
            
            // Add chunk mode change listeners
            document.querySelectorAll('input[name="chunkMode"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    const manualSection = document.getElementById('manualChunkSection');
                    if (this.value === 'manual') {
                        manualSection.style.display = 'block';
                    } else {
                        manualSection.style.display = 'none';
                    }
                    
                    // Update file info if a file is already selected
                    if (appState.selectedFile) {
                        updateChatFileInfo(appState.selectedFile);
                    }
                });
            });
            
            logSystem('Application initialization complete');
            console.log('All functions loaded:', { 
                showChatApplication: typeof showChatApplication, 
                clearAuthMessage: typeof clearAuthMessage,
                initAuth: typeof initAuth 
            });
        };
    </script>
</body>
</html>